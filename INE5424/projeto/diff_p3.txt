diff --git a/app/e6b_test/e6b_test.cc b/app/e6b_test/e6b_test.cc
new file mode 100644
index 0000000..c657fda
--- /dev/null
+++ b/app/e6b_test/e6b_test.cc
@@ -0,0 +1,76 @@
+#include <utility/ostream.h>
+#include <process.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+
+char * test_char = new (SHARED) char('a');
+
+int test1_b() {
+    *test_char = 'b';
+    return 0;
+}
+
+int test1_c() {
+    *test_char = 'c';
+    return 0;
+}
+
+int main() {
+
+    cout << "-----------------------" << endl;
+    cout << "Shared memory test" << endl;
+    cout << "-----------------------" << endl;
+
+    // Test 1: create a global variable in the shared memory 
+    // and manipulate it with two different threads
+    Thread * test1_b_thread = new Thread(&test1_b);
+    Thread * test1_c_thread = new Thread(&test1_c);
+
+    test1_b_thread->join();
+    test1_c_thread->join();
+
+    cout << "Asserting test char value" << endl;
+    assert(*test_char != 'a');
+    assert(*test_char != 'b');
+    assert(*test_char == 'c');
+
+    delete test_char;
+
+    // Test 2: after deleting a variable from the shared memory,
+    // create another one and change it's value
+    int * test_int = new (SHARED) int;
+    *test_int = 0;
+    *test_int += 1;
+
+    cout << "Asserting test int value" << endl;
+    assert(*test_int != 0);
+    assert(*test_int == 1);
+    assert(*test_int != 2);
+
+    delete test_int;
+
+    // Test 3: create and change the value of a variable
+    // using the default and the shared new operator
+
+    cout << "Asserting values of different operators" << endl;
+
+    int * test_shared_new = new (SHARED) int;
+    int * test_default_new = new int;
+    
+    *test_shared_new = 0;
+    *test_default_new = 1;
+
+    ++*test_shared_new;
+    ++*test_default_new;
+
+    assert(*test_shared_new == 1);
+    assert(*test_default_new == 2);
+
+    delete test_shared_new;
+    delete test_default_new;
+    
+    cout << "Finishing test..." << endl;
+}
\ No newline at end of file
diff --git a/app/e6b_test/e6b_test_traits.h b/app/e6b_test/e6b_test_traits.h
new file mode 100644
index 0000000..2d8b759
--- /dev/null
+++ b/app/e6b_test/e6b_test_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = true;
+    static const bool sharedmemory = true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    static const bool preemptive = true;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
\ No newline at end of file
diff --git a/app/e6b_test/makefile b/app/e6b_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/e6b_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/e7b_test/e7b_test.cc b/app/e7b_test/e7b_test.cc
new file mode 100644
index 0000000..9508a9e
--- /dev/null
+++ b/app/e7b_test/e7b_test.cc
@@ -0,0 +1,43 @@
+#include <utility/ostream.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+int testing();
+
+int main()
+{
+    Periodic_Thread::Configuration conf_a{5000, 1000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+    Periodic_Thread::Configuration conf_b{1500, 500, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+    Periodic_Thread::Configuration conf_c{25000, 5000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+
+    Periodic_Thread * a = new Periodic_Thread(conf_a, &testing);
+    Periodic_Thread * b = new Periodic_Thread(conf_b, &testing);
+    Periodic_Thread * c = new Periodic_Thread(conf_c, &testing);
+
+    a -> join();
+    b -> join();
+    c -> join();
+
+
+    delete a;
+    delete b;
+    delete c;
+
+    cout << "Finishing test..." << endl;
+
+    return 0;
+}
+
+int testing() {
+  int i = 0;
+  while ((i < 10) and Periodic_Thread::wait_next()) // iterator stops infinite runs.
+  {
+    cout << "Job finished\n" << endl;
+    i++;
+  }
+
+  return 0;
+}
\ No newline at end of file
diff --git a/app/e7b_test/e7b_test.h b/app/e7b_test/e7b_test.h
new file mode 100644
index 0000000..458ea1a
--- /dev/null
+++ b/app/e7b_test/e7b_test.h
@@ -0,0 +1,159 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = false;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = false;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool sharedmemory = true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef DM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<DM>: public Traits<Build>
+{
+    static const bool debugged = true;
+};
+
+__END_SYS
+
+#endif
\ No newline at end of file
diff --git a/app/e7b_test/makefile b/app/e7b_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/e7b_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 40c7c05..935df14 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -2,11 +2,12 @@
 
 using namespace EPOS;
 
-OStream cout;
+_SYS::OStream cout;
+_SYS::OStream endl;
 
 int main()
 {
-    cout << "Hello world!" << endl;
+    cout << "Hello world!";
 
     return 0;
 }
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 39f4b4c..1ec5d7e 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -9,7 +9,7 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = BUILTIN;
+    static const unsigned int MODE = KERNEL;
     static const unsigned int ARCHITECTURE = ARMv8;
     static const unsigned int MACHINE = Cortex;
     static const unsigned int MODEL = Raspberry_Pi3;
@@ -106,7 +106,8 @@ template<> struct Traits<System>: public Traits<Build>
     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
     static const bool multitask = (mode != Traits<Build>::LIBRARY);
     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool multiheap = true;
+    static const bool sharedmemory = true;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
diff --git a/app/p2_tests_addr_segment/makefile b/app/p2_tests_addr_segment/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/p2_tests_addr_segment/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/p2_tests_addr_segment/p2_tests_addr_segment.cc b/app/p2_tests_addr_segment/p2_tests_addr_segment.cc
new file mode 100644
index 0000000..9658edb
--- /dev/null
+++ b/app/p2_tests_addr_segment/p2_tests_addr_segment.cc
@@ -0,0 +1,39 @@
+#include <time.h>
+#include <process.h>
+#include <machine.h>
+#include <system.h>
+
+using namespace EPOS;
+
+int print_inf();
+int func_a();
+
+OStream cout;
+
+int main()
+{
+
+    cout << "-----------------------------" << endl;
+    cout << "Addres Space and Segment Test" << endl;
+    cout << "-----------------------------" << endl;
+    
+    System_Info * si = System::info();
+    cout << "System_Info app location" << endl;
+    cout << "App code segment = " << CPU::Phy_Addr(si->pmm.app_code) << endl;
+    cout << "App data segment = " << CPU::Phy_Addr(si->pmm.app_data) << endl;
+
+    Task * task = Task::self();
+    Address_Space * as = task->address_space();
+    cout << "Task address_space pd = " << as->pd() << endl;
+
+    CPU::Log_Addr code = task->code();
+    cout << "Testing APP_CODE..." << endl;
+    assert(code == Memory_Map::APP_CODE);
+
+    CPU::Log_Addr data = task->data();
+    cout << "Testing APP_DATA.." << endl;
+    assert(data == Memory_Map::APP_DATA);
+
+    cout << "Finishing test..." << endl;
+    
+}
\ No newline at end of file
diff --git a/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h b/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h
new file mode 100644
index 0000000..68e81c6
--- /dev/null
+++ b/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = ARMv8;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = true;
+    static const bool sharedmemory = true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/p2_tests_task/makefile b/app/p2_tests_task/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/p2_tests_task/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/p2_tests_task/p2_tests_task.cc b/app/p2_tests_task/p2_tests_task.cc
new file mode 100644
index 0000000..213e391
--- /dev/null
+++ b/app/p2_tests_task/p2_tests_task.cc
@@ -0,0 +1,42 @@
+#include <time.h>
+#include <process.h>
+#include <machine.h>
+#include <utility/fork.h>
+#include <system.h>
+
+using namespace EPOS;
+
+int print_inf();
+int func_a();
+
+OStream cout;
+
+int main()
+{
+    if (Task::self()->id() == 0) {
+        cout << "-----------------------" << endl;
+        cout << "Task Tests" << endl;
+        cout << "-----------------------" << endl;
+        fork(&main);
+    }
+    if (Task::self()->id() == 1) {
+        cout << "    -> Forked from main function " << endl;
+        int t_id = Task::self()->id();
+        assert(t_id == 1);
+        return 0;
+    }
+
+    Address_Space * as = Task::self()->address_space();
+    cout << "Address_Space pd = " << as->pd() << endl;
+
+    cout << "Task code addr = " << static_cast<void *>(Task::self()->code()) << endl;
+    cout << "Address_Space code physical addr = " << static_cast<void *>(as->physical(Task::self()->code())) << endl;
+    cout << "code_segment size = " << Task::self()->code_segment()->size() << endl;
+
+    cout << "Task data addr = " << static_cast<void *>(Task::self()->data()) << endl;
+    cout << "Address_Space data physical addr = " << static_cast<void *>(as->physical(Task::self()->data())) << endl;
+    cout << "data_segment size = " << Task::self()->data_segment()->size() << endl;
+
+    cout << "Finishing test..." << endl;
+    return 0;
+}
diff --git a/app/p2_tests_task/p2_tests_task_traits.h b/app/p2_tests_task/p2_tests_task_traits.h
new file mode 100644
index 0000000..68e81c6
--- /dev/null
+++ b/app/p2_tests_task/p2_tests_task_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = ARMv8;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = true;
+    static const bool sharedmemory = true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/p3_tests/makefile b/app/p3_tests/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/p3_tests/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/p3_tests/p3_tests.cc b/app/p3_tests/p3_tests.cc
new file mode 100644
index 0000000..dd4908d
--- /dev/null
+++ b/app/p3_tests/p3_tests.cc
@@ -0,0 +1,12 @@
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+_SYS::OStream cout;
+
+int main()
+{
+    cout << "Hello world!";
+
+    return 0;
+}
diff --git a/app/p3_tests/p3_tests_traits.h b/app/p3_tests/p3_tests_traits.h
new file mode 100644
index 0000000..1ec5d7e
--- /dev/null
+++ b/app/p3_tests/p3_tests_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = KERNEL;
+    static const unsigned int ARCHITECTURE = ARMv8;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = true;
+    static const bool sharedmemory = true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/diff_p2.txt b/diff_p2.txt
new file mode 100644
index 0000000..5b9a05c
--- /dev/null
+++ b/diff_p2.txt
@@ -0,0 +1,2998 @@
+diff --git a/app/e6b_test/e6b_test.cc b/app/e6b_test/e6b_test.cc
+new file mode 100644
+index 0000000..c657fda
+--- /dev/null
++++ b/app/e6b_test/e6b_test.cc
+@@ -0,0 +1,76 @@
++#include <utility/ostream.h>
++#include <process.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++
++char * test_char = new (SHARED) char('a');
++
++int test1_b() {
++    *test_char = 'b';
++    return 0;
++}
++
++int test1_c() {
++    *test_char = 'c';
++    return 0;
++}
++
++int main() {
++
++    cout << "-----------------------" << endl;
++    cout << "Shared memory test" << endl;
++    cout << "-----------------------" << endl;
++
++    // Test 1: create a global variable in the shared memory 
++    // and manipulate it with two different threads
++    Thread * test1_b_thread = new Thread(&test1_b);
++    Thread * test1_c_thread = new Thread(&test1_c);
++
++    test1_b_thread->join();
++    test1_c_thread->join();
++
++    cout << "Asserting test char value" << endl;
++    assert(*test_char != 'a');
++    assert(*test_char != 'b');
++    assert(*test_char == 'c');
++
++    delete test_char;
++
++    // Test 2: after deleting a variable from the shared memory,
++    // create another one and change it's value
++    int * test_int = new (SHARED) int;
++    *test_int = 0;
++    *test_int += 1;
++
++    cout << "Asserting test int value" << endl;
++    assert(*test_int != 0);
++    assert(*test_int == 1);
++    assert(*test_int != 2);
++
++    delete test_int;
++
++    // Test 3: create and change the value of a variable
++    // using the default and the shared new operator
++
++    cout << "Asserting values of different operators" << endl;
++
++    int * test_shared_new = new (SHARED) int;
++    int * test_default_new = new int;
++    
++    *test_shared_new = 0;
++    *test_default_new = 1;
++
++    ++*test_shared_new;
++    ++*test_default_new;
++
++    assert(*test_shared_new == 1);
++    assert(*test_default_new == 2);
++
++    delete test_shared_new;
++    delete test_default_new;
++    
++    cout << "Finishing test..." << endl;
++}
+\ No newline at end of file
+diff --git a/app/e6b_test/e6b_test_traits.h b/app/e6b_test/e6b_test_traits.h
+new file mode 100644
+index 0000000..2d8b759
+--- /dev/null
++++ b/app/e6b_test/e6b_test_traits.h
+@@ -0,0 +1,155 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = ARMv7;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = true;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    static const bool preemptive = true;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+\ No newline at end of file
+diff --git a/app/e6b_test/makefile b/app/e6b_test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/e6b_test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/e7b_test/e7b_test.cc b/app/e7b_test/e7b_test.cc
+new file mode 100644
+index 0000000..9508a9e
+--- /dev/null
++++ b/app/e7b_test/e7b_test.cc
+@@ -0,0 +1,43 @@
++#include <utility/ostream.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++int testing();
++
++int main()
++{
++    Periodic_Thread::Configuration conf_a{5000, 1000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++    Periodic_Thread::Configuration conf_b{1500, 500, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++    Periodic_Thread::Configuration conf_c{25000, 5000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++
++    Periodic_Thread * a = new Periodic_Thread(conf_a, &testing);
++    Periodic_Thread * b = new Periodic_Thread(conf_b, &testing);
++    Periodic_Thread * c = new Periodic_Thread(conf_c, &testing);
++
++    a -> join();
++    b -> join();
++    c -> join();
++
++
++    delete a;
++    delete b;
++    delete c;
++
++    cout << "Finishing test..." << endl;
++
++    return 0;
++}
++
++int testing() {
++  int i = 0;
++  while ((i < 10) and Periodic_Thread::wait_next()) // iterator stops infinite runs.
++  {
++    cout << "Job finished\n" << endl;
++    i++;
++  }
++
++  return 0;
++}
+\ No newline at end of file
+diff --git a/app/e7b_test/e7b_test.h b/app/e7b_test/e7b_test.h
+new file mode 100644
+index 0000000..458ea1a
+--- /dev/null
++++ b/app/e7b_test/e7b_test.h
+@@ -0,0 +1,159 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = ARMv7;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = false;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = false;
++    static const bool info    = false;
++    static const bool trace   = true;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef DM Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++template<> struct Traits<DM>: public Traits<Build>
++{
++    static const bool debugged = true;
++};
++
++__END_SYS
++
++#endif
+\ No newline at end of file
+diff --git a/app/e7b_test/makefile b/app/e7b_test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/e7b_test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
+index 39f4b4c..68e81c6 100644
+--- a/app/hello/hello_traits.h
++++ b/app/hello/hello_traits.h
+@@ -106,7 +106,8 @@ template<> struct Traits<System>: public Traits<Build>
+     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+     static const bool multitask = (mode != Traits<Build>::LIBRARY);
+     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool multiheap = true;
++    static const bool sharedmemory = true;
+ 
+     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+     static const unsigned int DUTY_CYCLE = 1000000; // ppm
+diff --git a/app/p2_tests_addr_segment/makefile b/app/p2_tests_addr_segment/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/p2_tests_addr_segment/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/p2_tests_addr_segment/p2_tests_addr_segment.cc b/app/p2_tests_addr_segment/p2_tests_addr_segment.cc
+new file mode 100644
+index 0000000..9658edb
+--- /dev/null
++++ b/app/p2_tests_addr_segment/p2_tests_addr_segment.cc
+@@ -0,0 +1,39 @@
++#include <time.h>
++#include <process.h>
++#include <machine.h>
++#include <system.h>
++
++using namespace EPOS;
++
++int print_inf();
++int func_a();
++
++OStream cout;
++
++int main()
++{
++
++    cout << "-----------------------------" << endl;
++    cout << "Addres Space and Segment Test" << endl;
++    cout << "-----------------------------" << endl;
++    
++    System_Info * si = System::info();
++    cout << "System_Info app location" << endl;
++    cout << "App code segment = " << CPU::Phy_Addr(si->pmm.app_code) << endl;
++    cout << "App data segment = " << CPU::Phy_Addr(si->pmm.app_data) << endl;
++
++    Task * task = Task::self();
++    Address_Space * as = task->address_space();
++    cout << "Task address_space pd = " << as->pd() << endl;
++
++    CPU::Log_Addr code = task->code();
++    cout << "Testing APP_CODE..." << endl;
++    assert(code == Memory_Map::APP_CODE);
++
++    CPU::Log_Addr data = task->data();
++    cout << "Testing APP_DATA.." << endl;
++    assert(data == Memory_Map::APP_DATA);
++
++    cout << "Finishing test..." << endl;
++    
++}
+\ No newline at end of file
+diff --git a/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h b/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h
+new file mode 100644
+index 0000000..68e81c6
+--- /dev/null
++++ b/app/p2_tests_addr_segment/p2_tests_addr_segment_traits.h
+@@ -0,0 +1,155 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = BUILTIN;
++    static const unsigned int ARCHITECTURE = ARMv8;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = true;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/app/p2_tests_task/makefile b/app/p2_tests_task/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/p2_tests_task/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/p2_tests_task/p2_tests_task.cc b/app/p2_tests_task/p2_tests_task.cc
+new file mode 100644
+index 0000000..213e391
+--- /dev/null
++++ b/app/p2_tests_task/p2_tests_task.cc
+@@ -0,0 +1,42 @@
++#include <time.h>
++#include <process.h>
++#include <machine.h>
++#include <utility/fork.h>
++#include <system.h>
++
++using namespace EPOS;
++
++int print_inf();
++int func_a();
++
++OStream cout;
++
++int main()
++{
++    if (Task::self()->id() == 0) {
++        cout << "-----------------------" << endl;
++        cout << "Task Tests" << endl;
++        cout << "-----------------------" << endl;
++        fork(&main);
++    }
++    if (Task::self()->id() == 1) {
++        cout << "    -> Forked from main function " << endl;
++        int t_id = Task::self()->id();
++        assert(t_id == 1);
++        return 0;
++    }
++
++    Address_Space * as = Task::self()->address_space();
++    cout << "Address_Space pd = " << as->pd() << endl;
++
++    cout << "Task code addr = " << static_cast<void *>(Task::self()->code()) << endl;
++    cout << "Address_Space code physical addr = " << static_cast<void *>(as->physical(Task::self()->code())) << endl;
++    cout << "code_segment size = " << Task::self()->code_segment()->size() << endl;
++
++    cout << "Task data addr = " << static_cast<void *>(Task::self()->data()) << endl;
++    cout << "Address_Space data physical addr = " << static_cast<void *>(as->physical(Task::self()->data())) << endl;
++    cout << "data_segment size = " << Task::self()->data_segment()->size() << endl;
++
++    cout << "Finishing test..." << endl;
++    return 0;
++}
+diff --git a/app/p2_tests_task/p2_tests_task_traits.h b/app/p2_tests_task/p2_tests_task_traits.h
+new file mode 100644
+index 0000000..68e81c6
+--- /dev/null
++++ b/app/p2_tests_task/p2_tests_task_traits.h
+@@ -0,0 +1,155 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = BUILTIN;
++    static const unsigned int ARCHITECTURE = ARMv8;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = true;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/e6b.diff b/e6b.diff
+new file mode 100644
+index 0000000..e69de29
+diff --git a/e7b.diff b/e7b.diff
+new file mode 100644
+index 0000000..c5e96e1
+--- /dev/null
++++ b/e7b.diff
+@@ -0,0 +1,941 @@
++diff --git a/Dockerfile b/Dockerfile
++new file mode 100644
++index 0000000..33be31f
++--- /dev/null
+++++ b/Dockerfile
++@@ -0,0 +1,51 @@
+++FROM ubuntu:focal
+++
+++WORKDIR /home
+++
+++ENV TZ=America/Sao_Paulo
+++RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ
+++
+++RUN apt-get update && \
+++    apt-get install -y \
+++        bc \
+++        bin86 \
+++        build-essential \
+++        g++-multilib \
+++        gcc-multilib \
+++        gdb \
+++        gdb-multiarch \
+++        make \
+++        python3 \
+++        python3-pip \
+++        qemu \
+++        qemu-kvm \
+++        qemu-system-arm \
+++        tar \
+++        tcsh \
+++        wget \
+++        xterm && \
+++    apt-get clean && \
+++    rm -rf /var/lib/apt/lists/*
+++
+++RUN wget https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init_1.2.2_amd64.deb && \
+++    dpkg -i dumb-init_*.deb && \
+++    rm dumb-init_*.deb
+++
+++RUN wget -q -O ia32.tar.gz https://epos.lisha.ufsc.br/dl469 && \
+++    tar -zxvf ia32.tar.gz && \
+++    mkdir -p /usr/local/ia32/ && \
+++    mv gcc-7.2.0 /usr/local/ia32/ && \
+++    rm -r ia32.tar.gz
+++
+++RUN wget -q -O arm.tar.gz https://epos.lisha.ufsc.br/dl468 && \
+++    tar -zxvf arm.tar.gz && \
+++    mkdir -p /usr/local/arm/ && \
+++    mv gcc-7.2.0 /usr/local/arm/ && \
+++    rm -r arm.tar.gz
+++
+++ENV PATH="${PATH}:/usr/local/arm/gcc-7.2.0/bin/"
+++
+++VOLUME /code
+++WORKDIR /code
+++
+++ENTRYPOINT ["/usr/bin/dumb-init", "--"]
++diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
++index 77a3de8..512cac1 100644
++--- a/app/hello/hello_traits.h
+++++ b/app/hello/hello_traits.h
++@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
++     static const bool multitask = (mode != Traits<Build>::LIBRARY);
++     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+++    static const bool sharedmemory = true;
++ 
++     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++     static const unsigned int DUTY_CYCLE = 1000000; // ppm
++diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
++index 77a3de8..512cac1 100644
++--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++++ b/app/philosophers_dinner/philosophers_dinner_traits.h
++@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
++     static const bool multitask = (mode != Traits<Build>::LIBRARY);
++     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+++    static const bool sharedmemory = true;
++ 
++     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++     static const unsigned int DUTY_CYCLE = 1000000; // ppm
++diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
++index 77a3de8..512cac1 100644
++--- a/app/producer_consumer/producer_consumer_traits.h
+++++ b/app/producer_consumer/producer_consumer_traits.h
++@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
++     static const bool multitask = (mode != Traits<Build>::LIBRARY);
++     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+++    static const bool sharedmemory = true;
++ 
++     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++     static const unsigned int DUTY_CYCLE = 1000000; // ppm
++diff --git a/app/test_deadline/makefile b/app/test_deadline/makefile
++new file mode 100644
++index 0000000..8a6578a
++--- /dev/null
+++++ b/app/test_deadline/makefile
++@@ -0,0 +1,17 @@
+++# EPOS Application Makefile
+++
+++include ../../makedefs
+++
+++all: install
+++
+++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+++
+++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+++		$(ACC) $(ACCFLAGS) -o $@ $<
+++
+++install: $(APPLICATION)
+++		$(INSTALL) $(APPLICATION) $(IMG)
+++
+++clean:
+++		$(CLEAN) *.o $(APPLICATION)
++diff --git a/app/test_deadline/test_deadline.cc b/app/test_deadline/test_deadline.cc
++new file mode 100644
++index 0000000..9508a9e
++--- /dev/null
+++++ b/app/test_deadline/test_deadline.cc
++@@ -0,0 +1,43 @@
+++#include <utility/ostream.h>
+++#include <real-time.h>
+++
+++using namespace EPOS;
+++
+++OStream cout;
+++
+++int testing();
+++
+++int main()
+++{
+++    Periodic_Thread::Configuration conf_a{5000, 1000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+++    Periodic_Thread::Configuration conf_b{1500, 500, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+++    Periodic_Thread::Configuration conf_c{25000, 5000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
+++
+++    Periodic_Thread * a = new Periodic_Thread(conf_a, &testing);
+++    Periodic_Thread * b = new Periodic_Thread(conf_b, &testing);
+++    Periodic_Thread * c = new Periodic_Thread(conf_c, &testing);
+++
+++    a -> join();
+++    b -> join();
+++    c -> join();
+++
+++
+++    delete a;
+++    delete b;
+++    delete c;
+++
+++    cout << "Finishing test..." << endl;
+++
+++    return 0;
+++}
+++
+++int testing() {
+++  int i = 0;
+++  while ((i < 10) and Periodic_Thread::wait_next()) // iterator stops infinite runs.
+++  {
+++    cout << "Job finished\n" << endl;
+++    i++;
+++  }
+++
+++  return 0;
+++}
++\ No newline at end of file
++diff --git a/app/test_deadline/test_deadline_traits.h b/app/test_deadline/test_deadline_traits.h
++new file mode 100644
++index 0000000..2805c20
++--- /dev/null
+++++ b/app/test_deadline/test_deadline_traits.h
++@@ -0,0 +1,159 @@
+++#ifndef __traits_h
+++#define __traits_h
+++
+++#include <system/config.h>
+++
+++__BEGIN_SYS
+++
+++// Build
+++template<> struct Traits<Build>: public Traits_Tokens
+++{
+++    // Basic configuration
+++    static const unsigned int MODE = LIBRARY;
+++    static const unsigned int ARCHITECTURE = ARMv7;
+++    static const unsigned int MACHINE = Cortex;
+++    static const unsigned int MODEL = Raspberry_Pi3;
+++    static const unsigned int CPUS = 1;
+++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+++
+++    // Default flags
+++    static const bool enabled = true;
+++    static const bool monitored = false;
+++    static const bool debugged = false;
+++    static const bool hysterically_debugged = false;
+++
+++    // Default aspects
+++    typedef ALIST<> ASPECTS;
+++};
+++
+++
+++// Utilities
+++template<> struct Traits<Debug>: public Traits<Build>
+++{
+++    static const bool error   = true;
+++    static const bool warning = false;
+++    static const bool info    = false;
+++    static const bool trace   = true;
+++};
+++
+++template<> struct Traits<Lists>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Spin>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Heaps>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Observers>: public Traits<Build>
+++{
+++    // Some observed objects are created before initializing the Display
+++    // Enabling debug may cause trouble in some Machines
+++    static const bool debugged = false;
+++};
+++
+++
+++// System Parts (mostly to fine control debugging)
+++template<> struct Traits<Boot>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Setup>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Init>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Framework>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Aspect>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++
+++__END_SYS
+++
+++// Mediators
+++#include __ARCHITECTURE_TRAITS_H
+++#include __MACHINE_TRAITS_H
+++
+++__BEGIN_SYS
+++
+++
+++// API Components
+++template<> struct Traits<Application>: public Traits<Build>
+++{
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+++};
+++
+++template<> struct Traits<System>: public Traits<Build>
+++{
+++    static const unsigned int mode = Traits<Build>::MODE;
+++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+++    static const bool sharedmemory = true;
+++
+++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+++
+++    static const bool reboot = true;
+++
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+++};
+++
+++template<> struct Traits<Task>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multitask;
+++};
+++
+++template<> struct Traits<Thread>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++    static const bool smp = Traits<System>::multicore;
+++    static const bool trace_idle = hysterically_debugged;
+++    static const bool simulate_capacity = false;
+++
+++    typedef DM Criterion;
+++    static const unsigned int QUANTUM = 10000; // us
+++};
+++
+++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+++{
+++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+++};
+++
+++template<> struct Traits<Synchronizer>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++};
+++
+++template<> struct Traits<Alarm>: public Traits<Build>
+++{
+++    static const bool visible = hysterically_debugged;
+++};
+++
+++template<> struct Traits<DM>: public Traits<Build>
+++{
+++    static const bool debugged = true;
+++};
+++
+++__END_SYS
+++
+++#endif
++diff --git a/app/test_shared_memory/makefile b/app/test_shared_memory/makefile
++new file mode 100644
++index 0000000..8a6578a
++--- /dev/null
+++++ b/app/test_shared_memory/makefile
++@@ -0,0 +1,17 @@
+++# EPOS Application Makefile
+++
+++include ../../makedefs
+++
+++all: install
+++
+++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+++
+++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+++		$(ACC) $(ACCFLAGS) -o $@ $<
+++
+++install: $(APPLICATION)
+++		$(INSTALL) $(APPLICATION) $(IMG)
+++
+++clean:
+++		$(CLEAN) *.o $(APPLICATION)
++diff --git a/app/test_shared_memory/test_shared_memory.cc b/app/test_shared_memory/test_shared_memory.cc
++new file mode 100644
++index 0000000..5d4a190
++--- /dev/null
+++++ b/app/test_shared_memory/test_shared_memory.cc
++@@ -0,0 +1,77 @@
+++#include <utility/ostream.h>
+++#include <process.h>
+++
+++using namespace EPOS;
+++
+++OStream cout;
+++
+++
+++char * test_char = new (SHARED) char('a');
+++
+++int test1_b() {
+++    *test_char = 'b';
+++    return 0;
+++}
+++
+++int test1_c() {
+++    *test_char = 'c';
+++    return 0;
+++}
+++
+++int main() {
+++
+++    cout << "-----------------------" << endl;
+++    cout << "Shared memory test" << endl;
+++    cout << "-----------------------" << endl;
+++
+++    // Test 1: create a global variable in the shared memory 
+++    // and manipulate it with two different threads
+++    Thread * test1_b_thread = new Thread(&test1_b);
+++    Thread * test1_c_thread = new Thread(&test1_c);
+++
+++    test1_b_thread->join();
+++    test1_c_thread->join();
+++
+++    cout << "Asserting test char value" << endl;
+++    assert(*test_char != 'a');
+++    assert(*test_char != 'b');
+++    assert(*test_char == 'c');
+++
+++    delete test_char;
+++
+++    // Test 2: after deleting a variable from the shared memory,
+++    // create another one and change it's value
+++    int * test_int = new (SHARED) int;
+++    *test_int = 0;
+++    *test_int += 1;
+++
+++    cout << "Asserting test int value" << endl;
+++    assert(*test_int != 0);
+++    assert(*test_int == 1);
+++    assert(*test_int != 2);
+++
+++    delete test_int;
+++
+++    // Test 3: create and change the value of a variable in the
+++    // system, application and shared heap
+++
+++    cout << "Asserting variables in different heaps" << endl;
+++
+++    int * test_shared_var = new (SHARED) int;
+++    int * test_system_var = new (SYSTEM) int;
+++    int * test_application_var = new int;
+++    
+++    *test_shared_var = 0;
+++    *test_system_var = 1;
+++    *test_application_var = 2;
+++
+++    ++*test_shared_var;
+++    ++*test_system_var;
+++    ++*test_application_var;
+++
+++    assert(*test_shared_var == 1);
+++    assert(*test_system_var == 2);
+++    assert(*test_application_var == 3);
+++    
+++    cout << "Finishing test..." << endl;
+++}
++\ No newline at end of file
++diff --git a/app/test_shared_memory/test_shared_memory_traits.h b/app/test_shared_memory/test_shared_memory_traits.h
++new file mode 100644
++index 0000000..b5e047e
++--- /dev/null
+++++ b/app/test_shared_memory/test_shared_memory_traits.h
++@@ -0,0 +1,156 @@
+++#ifndef __traits_h
+++#define __traits_h
+++
+++#include <system/config.h>
+++
+++__BEGIN_SYS
+++
+++// Build
+++template<> struct Traits<Build>: public Traits_Tokens
+++{
+++    // Basic configuration
+++    static const unsigned int MODE = LIBRARY;
+++    static const unsigned int ARCHITECTURE = ARMv7;
+++    static const unsigned int MACHINE = Cortex;
+++    static const unsigned int MODEL = Raspberry_Pi3;
+++    static const unsigned int CPUS = 1;
+++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+++
+++    // Default flags
+++    static const bool enabled = true;
+++    static const bool monitored = false;
+++    static const bool debugged = true;
+++    static const bool hysterically_debugged = false;
+++
+++    // Default aspects
+++    typedef ALIST<> ASPECTS;
+++};
+++
+++
+++// Utilities
+++template<> struct Traits<Debug>: public Traits<Build>
+++{
+++    static const bool error   = true;
+++    static const bool warning = true;
+++    static const bool info    = false;
+++    static const bool trace   = false;
+++};
+++
+++template<> struct Traits<Lists>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Spin>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Heaps>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Observers>: public Traits<Build>
+++{
+++    // Some observed objects are created before initializing the Display
+++    // Enabling debug may cause trouble in some Machines
+++    static const bool debugged = false;
+++};
+++
+++
+++// System Parts (mostly to fine control debugging)
+++template<> struct Traits<Boot>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Setup>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Init>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Framework>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Aspect>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++
+++__END_SYS
+++
+++// Mediators
+++#include __ARCHITECTURE_TRAITS_H
+++#include __MACHINE_TRAITS_H
+++
+++__BEGIN_SYS
+++
+++
+++// API Components
+++template<> struct Traits<Application>: public Traits<Build>
+++{
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+++};
+++
+++template<> struct Traits<System>: public Traits<Build>
+++{
+++    static const unsigned int mode = Traits<Build>::MODE;
+++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+++    static const bool multiheap = true;
+++    static const bool sharedmemory = true;
+++
+++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+++
+++    static const bool reboot = true;
+++
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+++};
+++
+++template<> struct Traits<Task>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multitask;
+++};
+++
+++template<> struct Traits<Thread>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++    static const bool smp = Traits<System>::multicore;
+++    static const bool trace_idle = hysterically_debugged;
+++    static const bool simulate_capacity = false;
+++
+++    typedef DM Criterion;
+++    static const bool preemptive = true;
+++    static const unsigned int QUANTUM = 10000; // us
+++};
+++
+++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+++{
+++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+++};
+++
+++template<> struct Traits<Synchronizer>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++};
+++
+++template<> struct Traits<Alarm>: public Traits<Build>
+++{
+++    static const bool visible = hysterically_debugged;
+++};
+++
+++
+++__END_SYS
+++
+++#endif
++diff --git a/dockepos b/dockepos
++new file mode 100644
++index 0000000..7f801ce
++--- /dev/null
+++++ b/dockepos
++@@ -0,0 +1,10 @@
+++#! /bin/bash
+++
+++docker run -it --rm \
+++-v $(pwd):/code \
+++-v "/tmp/.X11-unix:/tmp/.X11-unix:rw" \
+++-e "DISPLAY" \
+++-e 'QEMU_AUDIO_DRV=none' \
+++-u $(id -u):$(id -g) \
+++pico/dockepos \
+++$@
++diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
++index 17ea7d9..c3c4511 100644
++--- a/include/architecture/mmu.h
+++++ b/include/architecture/mmu.h
++@@ -50,6 +50,7 @@ public:
++             IO   = 1 << 8, // Memory Mapped I/O (0=memory, 1=I/O)
++             SYS  = (PRE | RD | RW | EX),
++             APP  = (PRE | RD | RW | EX | USR),
+++            SHR  = (PRE | RD | RW | EX | USR),
++             APPC = (PRE | RD | EX | USR),
++             APPD = (PRE | RD | RW | USR)
++         };
++diff --git a/include/real-time.h b/include/real-time.h
++index 4f53875..e5559fd 100644
++--- a/include/real-time.h
+++++ b/include/real-time.h
++@@ -25,13 +25,14 @@ typedef Thread Aperiodic_Thread;
++ class Periodic_Thread: public Thread
++ {
++ public:
++-    enum {
++-        SAME    = Real_Time_Scheduler_Common::SAME,
++-        NOW     = Real_Time_Scheduler_Common::NOW,
++-        UNKNOWN = Real_Time_Scheduler_Common::UNKNOWN,
++-        ANY     = Real_Time_Scheduler_Common::ANY
+++    enum : unsigned int {
+++        SAME    = 0,
+++        NOW     = 0,
+++        UNKNOWN = 0,
+++        ANY     = -1U
++     };
++ 
+++
++ protected:
++     // Alarm Handler for periodic threads under static scheduling policies
++     class Static_Handler: public Semaphore_Handler
++@@ -75,7 +76,12 @@ public:
++ public:
++     template<typename ... Tn>
++     Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
++-    : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+++    : Thread(Thread::Configuration(SUSPENDED, Criterion(p, p)), entry, an ...),
+++      _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+++
+++    template<typename ... Tn>
+++    Periodic_Thread(const Microsecond & p, const Microsecond d, int (* entry)(Tn ...), Tn ... an)
+++    : Thread(Thread::Configuration(SUSPENDED, Criterion(d, p)), entry, an ...),
++       _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
++ 
++     template<typename ... Tn>
++@@ -96,6 +102,7 @@ public:
++         Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
++ 
++         db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+++        db<DM> (TRC) << "Thread " << t << " started working. Period: " << t->criterion() << endl;
++ 
++         if(t->_alarm.times())
++             t->_semaphore.p();
++diff --git a/include/scheduler.h b/include/scheduler.h
++index 99bfd36..e86be96 100644
++--- a/include/scheduler.h
+++++ b/include/scheduler.h
++@@ -145,6 +145,38 @@ public:
++     FCFS(int p = NORMAL, Tn & ... an);
++ };
++ 
+++class Real_Time_Scheduler: public Priority
+++{
+++protected:
+++    Real_Time_Scheduler(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {}
+++    Real_Time_Scheduler(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
+++    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
+++
+++public:
+++    const Microsecond period() { return _period; }
+++    void period(const Microsecond & p) { _period = p; }
+++
+++public:
+++    Microsecond _deadline;
+++    Microsecond _period;
+++    Microsecond _capacity;
+++};
+++
+++// Deadline Monotonic
+++class DM: public Real_Time_Scheduler
+++{
+++
+++public:
+++    static const bool timed = false;
+++    static const bool dynamic = false;
+++    static const bool preemptive = true;
+++
+++public:
+++    DM(int p = APERIODIC): Real_Time_Scheduler(p) {}
+++    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+++    : Real_Time_Scheduler(d, d, p, c) {}
+++};
+++
++ __END_SYS
++ 
++-#endif
+++#endif
++\ No newline at end of file
++diff --git a/include/system.h b/include/system.h
++index 5215ef1..63b03e8 100644
++--- a/include/system.h
+++++ b/include/system.h
++@@ -47,13 +47,29 @@ private:
++     static char _preheap[(Traits<System>::multiheap ? sizeof(Segment) : 0) + sizeof(Heap)];
++     static Segment * _heap_segment;
++     static Heap * _heap;
+++    static Segment * _shared_segment;
+++};
+++
+++// Class used to store and handle the shared memory heap with the "new (SHARED)" operator
+++class Shared_Memory {
+++    friend class Init_System;
+++    friend void * ::malloc(size_t);
+++    friend void ::free(void*);
+++    friend void * ::operator new(size_t, const EPOS::Shared_Allocator&);
+++    friend void * ::operator new[](size_t, const EPOS::Shared_Allocator&);
+++    friend void ::operator delete(void*);
+++    friend void ::operator delete[](void*);
+++
+++    private:
+++    static char _preheap[sizeof(Segment) + sizeof(Heap)];
+++    static Segment * _shared_heap_segment;
+++    static Heap * _shared_heap;
++ };
++ 
++ __END_SYS
++ 
++ extern "C"
++ {
++-    // Standard C Library allocators
++     inline void * malloc(size_t bytes) {
++         __USING_SYS;
++         if(Traits<System>::multiheap)
++@@ -94,6 +110,14 @@ inline void * operator new[](size_t bytes, const EPOS::System_Allocator & alloca
++     return _SYS::System::_heap->alloc(bytes);
++ }
++ 
+++inline void * operator new(size_t bytes, const EPOS::Shared_Allocator & allocator) {
+++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
+++}
+++
+++inline void * operator new[](size_t bytes, const EPOS::Shared_Allocator & allocator) {
+++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
+++}
+++
++ // Delete cannot be declared inline due to virtual destructors
++ void operator delete(void * ptr);
++ void operator delete[](void * ptr);
++diff --git a/include/system/traits.h b/include/system/traits.h
++index 5e505ed..7aeb447 100644
++--- a/include/system/traits.h
+++++ b/include/system/traits.h
++@@ -93,6 +93,7 @@ class Keypad;
++ // API Components
++ class System;
++ class Application;
+++class Shared_Memory;
++ 
++ class Thread;
++ class Active;
++diff --git a/include/system/types.h b/include/system/types.h
++index 645c2df..d0259ba 100644
++--- a/include/system/types.h
+++++ b/include/system/types.h
++@@ -9,6 +9,7 @@ __BEGIN_API
++ 
++ // Memory allocators
++ enum System_Allocator { SYSTEM };
+++enum Shared_Allocator { SHARED };
++ enum Scratchpad_Allocator { SCRATCHPAD };
++ enum Color {
++     COLOR_0,  COLOR_1,  COLOR_2,  COLOR_3,  COLOR_4,  COLOR_5,  COLOR_6,  COLOR_7,
++@@ -44,6 +45,9 @@ inline void * operator new[](size_t s, void * a) { return a; }
++ void * operator new(size_t, const EPOS::System_Allocator &);
++ void * operator new[](size_t, const EPOS::System_Allocator &);
++ 
+++void * operator new(size_t, const EPOS::Shared_Allocator &);
+++void * operator new[](size_t, const EPOS::Shared_Allocator &);
+++
++ void * operator new(size_t, const EPOS::Scratchpad_Allocator &);
++ void * operator new[](size_t, const EPOS::Scratchpad_Allocator &);
++ 
++diff --git a/include/time.h b/include/time.h
++index 8608ce0..7b7d168 100644
++--- a/include/time.h
+++++ b/include/time.h
++@@ -34,6 +34,7 @@ class Alarm
++     friend class Alarm_Chronometer;             // for elapsed()
++     friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
++     friend class FCFS;                          // for ticks() and elapsed()
+++    friend class DM;
++ 
++ private:
++     typedef Timer_Common::Tick Tick;
++
++diff --git a/makedefs b/makedefs
++index 09760e0..9dd2176 100644
++--- a/makedefs
+++++ b/makedefs
++@@ -93,8 +93,8 @@ UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g
++ 
++ # Compiler prefixes
++ ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
++-armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
++-armv8_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
+++armv7_COMP_PREFIX       := /usr/local/arm/gcc-7.2.0/bin/arm-
+++armv8_COMP_PREFIX       := /usr/local/arm/gcc-7.2.0/bin/arm-
++ rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
++ rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
++ COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
++@@ -116,11 +116,11 @@ cortex_CC_FLAGS		:= -mcpu=cortex-a9
++ cortex_AS_FLAGS		:= -mcpu=cortex-a9
++ cortex_LD_FLAGS		:=
++ cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++-cortex_DEBUGGER		:= arm-none-eabi-gdb
+++cortex_DEBUGGER		:= gdb-multiarch
++ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
++ cortex_MAGIC		:= --omagic
++ cortex_CODE_NAME	:= .init
++-cortex_DATA_NAME	:= .data
+++cortex_DATA_NAME	:=
++ cortex_IMG_SUFFIX	:= .bin
++ endif
++ 
++@@ -128,11 +128,11 @@ ifeq ($(MMOD),zynq)
++ cortex_CC_FLAGS		:= -mcpu=cortex-a9
++ cortex_AS_FLAGS		:= -mcpu=cortex-a9
++ cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++-cortex_DEBUGGER		:= arm-none-eabi-gdb
+++cortex_DEBUGGER		:= gdb-multiarch
++ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
++ cortex_MAGIC		:= --omagic
++ cortex_CODE_NAME	:= .init
++-cortex_DATA_NAME	:= .data
+++cortex_DATA_NAME	:=
++ cortex_IMG_SUFFIX	:= .bin
++ endif
++ 
++@@ -140,12 +140,12 @@ ifeq ($(MMOD),raspberry_pi3)
++ cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
++ cortex_AS_FLAGS		:= -mcpu=cortex-a53
++ cortex_LD_FLAGS		:=
++-cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -device loader,file=$(APPLICATION).img,addr=$(IMAGE_ADDR),force-raw=on -kernel 
++-cortex_DEBUGGER		:= gdb
+++cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+++cortex_DEBUGGER		:= gdb-multiarch
++ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
++-cortex_MAGIC		:= --nmagic
+++cortex_MAGIC		:= --omagic
++ cortex_CODE_NAME	:= .init
++-cortex_DATA_NAME	:= .data
+++cortex_DATA_NAME	:=
++ cortex_IMG_SUFFIX	:= .bin
++ endif
++ 
++@@ -154,7 +154,7 @@ cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial m
++ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
++ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
++ cortex_LD_FLAGS		:=
++-cortex_DEBUGGER		:= arm-none-eabi-gdb
+++cortex_DEBUGGER		:= gdb-multiarch
++ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
++ cortex_MAGIC		:= --omagic
++ cortex_CODE_NAME	:= .init
++@@ -167,7 +167,7 @@ cortex_EMULATOR		=
++ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
++ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
++ cortex_LD_FLAGS		:=
++-cortex_DEBUGGER		:= arm-none-eabi-gdb
+++cortex_DEBUGGER		:= gdb-multiarch
++ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
++ cortex_MAGIC		:= --omagic
++ cortex_CODE_NAME	:= .init
++@@ -315,7 +315,7 @@ TEE		:= tee
++ ifndef DISPLAY
++ TERM        := sh -c
++ else
++-TERM        := konsole -e
+++TERM        := xterm -e
++ endif
++ 
++ TOUCH		:= touch
++diff --git a/src/init/init_system.cc b/src/init/init_system.cc
++index fefda22..194f864 100644
++--- a/src/init/init_system.cc
+++++ b/src/init/init_system.cc
++@@ -32,6 +32,19 @@ public:
++             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
++         db<Init>(INF) << "done!" << endl;
++ 
+++        ///////////////////////////////
+++
+++        // If the trait sharedmemory is true, a segment with the same size of
+++        // the system's heap will be allocated to be shared
+++        db<Init>(INF) << "Initializing shared memory:" << endl;
+++        if(Traits<System>::sharedmemory) {
+++            Shared_Memory::_shared_heap_segment = new(&Shared_Memory::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SHR);
+++            Shared_Memory::_shared_heap = new(&Shared_Memory::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Shared_Memory::_shared_heap_segment), Shared_Memory::_shared_heap_segment->size());
+++        }
+++        db<Init>(INF)<<"done!"<<endl;
+++
+++        ///////////////////////////////
+++
++         db<Init>(INF) << "Initializing the machine: " << endl;
++         Machine::init();
++         db<Init>(INF) << "done!" << endl;
++diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
++index 93089ce..0599311 100644
++--- a/src/system/system_scaffold.cc
+++++ b/src/system/system_scaffold.cc
++@@ -19,6 +19,9 @@ System_Info * System::_si = reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO
++ char System::_preheap[];
++ Segment * System::_heap_segment;
++ Heap * System::_heap;
+++char Shared_Memory::_preheap[];
+++Segment * Shared_Memory:: _shared_heap_segment;
+++Heap * Shared_Memory:: _shared_heap;
++ 
++ __END_SYS
++ 
+\ No newline at end of file
+diff --git a/include/architecture/armv8/armv8_cpu.h b/include/architecture/armv8/armv8_cpu.h
+index e063d5e..d25cefc 100644
+--- a/include/architecture/armv8/armv8_cpu.h
++++ b/include/architecture/armv8/armv8_cpu.h
+@@ -349,7 +349,10 @@ public:
+     static Reg  pd() { return ttbr0(); }
+     static void pd(Reg r) {  ttbr0(r); }
+ 
+-    static void flush_tlb();
++   static void flush_tlb() {
++       db<MMU>(TRC) << "CPU::flush_tlb() " << endl;
++       ASM("hvc #0                                   \t\n");
++   }
+     static void flush_tlb(Reg r);
+ 
+     static void flush_branch_predictors();
+diff --git a/include/architecture/armv8/armv8_mmu.h b/include/architecture/armv8/armv8_mmu.h
+index d33def1..b879819 100644
+--- a/include/architecture/armv8/armv8_mmu.h
++++ b/include/architecture/armv8/armv8_mmu.h
+@@ -270,6 +270,7 @@ template<unsigned int ENTRIES>
+         void activate() const { ARMv8_MMU::pd(_pd); }
+ 
+         Log_Addr attach(const Chunk & chunk, unsigned int from = directory(APP_LOW)) {
++            flush_tlb();
+             for(unsigned int i = from; i < directory(SYS); i++)
+                 if(attach(i, chunk.pt(), chunk.pts(), chunk.flags()))
+                     return i << DIRECTORY_SHIFT;
+@@ -277,6 +278,7 @@ template<unsigned int ENTRIES>
+         }
+ 
+         Log_Addr attach(const Chunk & chunk, Log_Addr addr) {
++            flush_tlb();
+             unsigned int from = directory(addr);
+             if(attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
+                 return from << DIRECTORY_SHIFT;
+@@ -284,6 +286,7 @@ template<unsigned int ENTRIES>
+         }
+ 
+         void detach(const Chunk & chunk) {
++            flush_tlb();
+             for(unsigned int i = 0; i < PD_ENTRIES; i++) {
+                 if(indexes(pte2phy((*_pd)[i])) == indexes(chunk.pt())) {
+                     detach(i, chunk.pt(), chunk.pts());
+@@ -294,6 +297,7 @@ template<unsigned int ENTRIES>
+         }
+ 
+         void detach(const Chunk & chunk, Log_Addr addr) {
++            flush_tlb();
+             unsigned int from = directory(addr);
+             if(indexes(pte2phy((*_pd)[from])) != indexes(chunk.pt())) {
+                 db<MMU>(WRN) << "MMU::Directory::detach(pt=" << chunk.pt() << ",addr=" << addr << ") failed!" << endl;
+@@ -311,6 +315,7 @@ template<unsigned int ENTRIES>
+ 
+     private:
+         bool attach(unsigned int from, const Page_Table * pt, unsigned int n, Page_Flags flags) {
++            flush_tlb();
+             for(unsigned int i = from; i < from + n; i++)
+                 if(_pd->log()[i])
+                     return false;
+@@ -320,7 +325,9 @@ template<unsigned int ENTRIES>
+         }
+ 
+         void detach(unsigned int from, const Page_Table * pt, unsigned int n) {
++            flush_tlb();
+             for(unsigned int i = from; i < from + n; i++) {
++                flush_tlb();
+                 _pd->log()[i] = 0;
+                 // flush_tlb(i << DIRECTORY_SHIFT);
+             }
+@@ -471,10 +478,10 @@ public:
+     }
+ 
+     static Phy_Addr pd() { return CPU::pd(); }
+-    static void pd(Phy_Addr pd) { CPU::pd(pd); /*CPU::flush_tlb();*/ CPU::isb(); CPU::dsb(); }
++    static void pd(Phy_Addr pd) { CPU::pd(pd); CPU::flush_tlb(); CPU::isb(); CPU::dsb(); }
+ 
+-    static void flush_tlb() { /*CPU::flush_tlb();*/ }
+-    static void flush_tlb(Log_Addr addr) { /*CPU::flush_tlb(directory_bits(addr));*/ } // only bits from 31 to 12, all ASIDs
++    static void flush_tlb() { CPU::flush_tlb(); }
++    static void flush_tlb(Log_Addr addr) { CPU::flush_tlb(directory_bits(addr)); } // only bits from 31 to 12, all ASIDs
+ 
+     static void init();
+ 
+diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
+index 4ebfbfe..a0fdb03 100644
+--- a/include/architecture/mmu.h
++++ b/include/architecture/mmu.h
+@@ -50,6 +50,7 @@ public:
+             IO   = 1 << 8, // Memory Mapped I/O (0=memory, 1=I/O)
+             SYS  = (PRE | RD | RW | EX),
+             APP  = (PRE | RD | RW | EX | USR),
++            SHR  = (PRE | RD | RW | EX | USR),
+             APPC = (PRE | RD | EX | USR),
+             APPD = (PRE | RD | RW | USR)
+         };
+diff --git a/include/memory.h b/include/memory.h
+index 63899b1..de38907 100644
+--- a/include/memory.h
++++ b/include/memory.h
+@@ -12,6 +12,7 @@ class Address_Space: private MMU::Directory
+     friend class Init_System;   // for Address_Space(pd)
+     friend class Thread;        // for Address_Space(pd)
+     friend class Scratchpad;    // for Address_Space(pd)
++    friend class Task;
+ 
+ private:
+     using MMU::Directory::activate;
+diff --git a/include/process.h b/include/process.h
+index e7beb71..cc50605 100644
+--- a/include/process.h
++++ b/include/process.h
+@@ -26,6 +26,7 @@ class Thread
+ protected:
+     static const bool preemptive = Traits<Thread>::Criterion::preemptive;
+     static const bool reboot = Traits<System>::reboot;
++    static const bool multitask = Traits<System>::multitask;
+ 
+     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+     static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
+@@ -58,12 +59,13 @@ public:
+ 
+     // Thread Configuration
+     struct Configuration {
+-        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+-        : state(s), criterion(c), stack_size(ss) {}
++        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE, Task * t = 0)
++        : state(s), criterion(c), stack_size(ss), task(t) {}
+ 
+         State state;
+         Criterion criterion;
+         unsigned int stack_size;
++        Task * task;
+     };
+ 
+ 
+@@ -86,6 +88,7 @@ public:
+     void resume();
+ 
+     static Thread * volatile self() { return running(); }
++    Task * task() const { return _task; }
+     static void yield();
+     static void exit(int status = 0);
+ 
+@@ -118,6 +121,7 @@ private:
+ 
+ protected:
+     char * _stack;
++    Task * _task;
+     Context * volatile _context;
+     volatile State _state;
+     Queue * _waiting;
+@@ -129,24 +133,92 @@ protected:
+     static Scheduler<Thread> _scheduler;
+ };
+ 
+-
+-template<typename ... Tn>
+-inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
+-: _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
++ // Task (only used in multitasking configurations)
++class Task
+ {
+-    constructor_prologue(STACK_SIZE);
+-    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
+-    constructor_epilogue(entry, STACK_SIZE);
+-}
++    friend class Thread;
+ 
+-template<typename ... Tn>
+-inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+-{
+-    constructor_prologue(conf.stack_size);
+-    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
+-    constructor_epilogue(entry, conf.stack_size);
+-}
++private:
++    typedef CPU::Log_Addr Log_Addr;
++    typedef CPU::Phy_Addr Phy_Addr;
++    typedef CPU::Context Context;
++
++protected:
++    template<typename ... Tn>
++    Task(Address_Space * as, Segment * cs, Segment * ds, int (* entry)(Tn ...), const Log_Addr & code, const Log_Addr & data, Tn ... an)
++    : _as(as), _cs(cs), _ds(ds), _entry(entry), _code(code), _data(data) {
++        db<Task, Init>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
++        lock();
++        _id = _task_count++;
++        unlock();
++        _current = this;
++        activate();
++        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN, Traits<Application>::STACK_SIZE, this), entry, an ...);
++    }
++
++public:
++    template<typename ... Tn>
++    Task(Segment * cs, Segment * ds, int (* entry)(Tn ...), const Log_Addr & code, const Log_Addr & data, Tn ... an)
++    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs, code)), _data(_as->attach(_ds, data)) {
++        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
++        lock();
++        _id = _task_count++;
++        unlock();
++        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::MAIN, Traits<Application>::STACK_SIZE, this), entry, an ...);
++    }
++    ~Task();
++
++    Address_Space * address_space() const { return _as; }
++
++    Segment * code_segment() const { return _cs; }
++    Segment * data_segment() const { return _ds; }
++
++    Log_Addr code() const { return _code; }
++    Log_Addr data() const { return _data; }
++
++    Thread * main() const { return _main; }
++
++    static Task * volatile self() { return current(); }
++    Log_Addr entry() { return _entry; }
++
++    unsigned int id() {return _id;}
++
++    void activate_context() {
++        activate();
++        MMU::flush_tlb();
++        lock();
++        _current = this;
++        unlock();
++    }
++
++private:
++    void activate() const { _as->activate(); }
++
++    void insert(Thread * t) { _threads.insert(new (SYSTEM) Thread::Queue::Element(t)); }
++    void remove(Thread * t) { Thread::Queue::Element * el = _threads.remove(t); if(el) delete el; }
++
++    static Task * volatile current() { return _current; }
++    static void current(Task * t) { _current = t; }
++
++    static void lock() { CPU::int_disable(); }
++    static void unlock() { CPU::int_enable(); }
++
++private:
++    unsigned int _id;
++    Address_Space * _as;
++    Segment * _cs;
++    Segment * _ds;
++    Log_Addr _entry;
++    Log_Addr _code;
++    Log_Addr _data;
++    Thread * _main;
++    Thread::Queue _threads;
++
++    static Task * volatile _current;
++
++protected:
++    static volatile unsigned int _task_count;
++};
+ 
+ 
+ // A Java-like Active Object
+@@ -178,6 +250,31 @@ private:
+     Thread * _handler;
+ };
+ 
++template<typename ... Tn>
++inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
++:_task(Task::self()), _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
++{
++    constructor_prologue(STACK_SIZE);
++    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
++    constructor_epilogue(entry, STACK_SIZE);
++
++    _task->insert(this);
++}
++
++template<typename ... Tn>
++inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
++:_task(conf.task ? conf.task : Task::self()), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
++{
++    constructor_prologue(conf.stack_size);
++    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
++    constructor_epilogue(entry, conf.stack_size);
++
++    // Not add Idle in task's threads list
++   if (conf.criterion != Thread::IDLE) {
++       _task->insert(this);
++   }
++}
++
+ __END_SYS
+ 
+ #endif
+diff --git a/include/real-time.h b/include/real-time.h
+new file mode 100644
+index 0000000..aef254e
+--- /dev/null
++++ b/include/real-time.h
+@@ -0,0 +1,116 @@
++// EPOS Real-time Declarations
++
++#ifndef __real_time_h
++#define __real_time_h
++
++#include <utility/handler.h>
++#include <utility/math.h>
++#include <utility/convert.h>
++#include <time.h>
++#include <process.h>
++#include <synchronizer.h>
++
++__BEGIN_SYS
++
++// Aperiodic Thread
++typedef Thread Aperiodic_Thread;
++
++// Periodic threads are achieved by programming an alarm handler to invoke
++// p() on a control semaphore after each job (i.e. task activation). Base
++// threads are created in BEGINNING state, so the scheduler won't dispatch
++// them before the associate alarm and semaphore are created. The first job
++// is dispatched by resume() (thus the _state = SUSPENDED statement)
++
++// Periodic Thread
++class Periodic_Thread: public Thread
++{
++public:
++    enum {
++        SAME    = Real_Time_Scheduler_Common::SAME,
++        NOW     = Real_Time_Scheduler_Common::NOW,
++        UNKNOWN = Real_Time_Scheduler_Common::UNKNOWN,
++        ANY     = Real_Time_Scheduler_Common::ANY
++    };
++
++protected:
++    // Alarm Handler for periodic threads under static scheduling policies
++    class Static_Handler: public Semaphore_Handler
++    {
++    public:
++        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
++        ~Static_Handler() {}
++    };
++
++    // Alarm Handler for periodic threads under dynamic scheduling policies
++    class Dynamic_Handler: public Semaphore_Handler
++    {
++    public:
++        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
++        ~Dynamic_Handler() {}
++
++        void operator()() {
++            _thread->criterion().update();
++
++            Semaphore_Handler::operator()();
++        }
++
++    private:
++        Periodic_Thread * _thread;
++    };
++
++    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
++
++public:
++    struct Configuration: public Thread::Configuration {
++        Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
++        : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
++
++        Microsecond period;
++        Microsecond deadline;
++        Microsecond capacity;
++        Microsecond activation;
++        unsigned int times;
++    };
++
++public:
++    template<typename ... Tn>
++    Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
++    : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
++      _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
++
++    template<typename ... Tn>
++    Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
++    : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
++      _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
++        if((conf.state == READY) || (conf.state == RUNNING)) {
++            _state = SUSPENDED;
++            resume();
++        } else
++            _state = conf.state;
++    }
++
++    const Microsecond & period() const { return _alarm.period(); }
++    void period(const Microsecond & p) { _alarm.period(p); }
++
++    static volatile bool wait_next() {
++        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
++
++        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
++
++        if(t->_alarm.times())
++            t->_semaphore.p();
++
++        return t->_alarm.times();
++    }
++
++protected:
++    Semaphore _semaphore;
++    Handler _handler;
++    Alarm _alarm;
++};
++
++typedef Periodic_Thread::Configuration RTConf;
++
++__END_SYS
++
++#endif
+\ No newline at end of file
+diff --git a/include/scheduler.h b/include/scheduler.h
+index 99bfd36..7e50828 100644
+--- a/include/scheduler.h
++++ b/include/scheduler.h
+@@ -145,6 +145,39 @@ public:
+     FCFS(int p = NORMAL, Tn & ... an);
+ };
+ 
++
++class Real_Time_Scheduler: public Priority
++{
++protected:
++    Real_Time_Scheduler(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {}
++    Real_Time_Scheduler(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
++    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
++
++public:
++    const Microsecond period() { return _period; }
++    void period(const Microsecond & p) { _period = p; }
++
++public:
++    Microsecond _deadline;
++    Microsecond _period;
++    Microsecond _capacity;
++};
++
++// Deadline Monotonic
++class DM: public Real_Time_Scheduler
++{
++
++public:
++    static const bool timed = false;
++    static const bool dynamic = false;
++    static const bool preemptive = true;
++
++public:
++    DM(int p = APERIODIC): Real_Time_Scheduler(p) {}
++    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
++    : Real_Time_Scheduler(d, d, p, c) {}
++};
++
+ __END_SYS
+ 
+ #endif
+diff --git a/include/system.h b/include/system.h
+index 5215ef1..cc98de1 100644
+--- a/include/system.h
++++ b/include/system.h
+@@ -47,6 +47,23 @@ private:
+     static char _preheap[(Traits<System>::multiheap ? sizeof(Segment) : 0) + sizeof(Heap)];
+     static Segment * _heap_segment;
+     static Heap * _heap;
++    static Segment * _shared_segment;
++};
++
++// Class used to store and handle the shared memory heap with the "new (SHARED)" operator
++class Shared_Memory {
++    friend class Init_System;
++    friend void * ::malloc(size_t);
++    friend void ::free(void*);
++    friend void * ::operator new(size_t, const EPOS::Shared_Allocator&);
++    friend void * ::operator new[](size_t, const EPOS::Shared_Allocator&);
++    friend void ::operator delete(void*);
++    friend void ::operator delete[](void*);
++
++    private:
++    static char _preheap[sizeof(Segment) + sizeof(Heap)];
++    static Segment * _shared_heap_segment;
++    static Heap * _shared_heap;
+ };
+ 
+ __END_SYS
+@@ -94,6 +111,14 @@ inline void * operator new[](size_t bytes, const EPOS::System_Allocator & alloca
+     return _SYS::System::_heap->alloc(bytes);
+ }
+ 
++inline void * operator new(size_t bytes, const EPOS::Shared_Allocator & allocator) {
++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
++}
++
++inline void * operator new[](size_t bytes, const EPOS::Shared_Allocator & allocator) {
++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
++}
++
+ // Delete cannot be declared inline due to virtual destructors
+ void operator delete(void * ptr);
+ void operator delete[](void * ptr);
+diff --git a/include/system/traits.h b/include/system/traits.h
+index 5e505ed..7aeb447 100644
+--- a/include/system/traits.h
++++ b/include/system/traits.h
+@@ -93,6 +93,7 @@ class Keypad;
+ // API Components
+ class System;
+ class Application;
++class Shared_Memory;
+ 
+ class Thread;
+ class Active;
+diff --git a/include/system/types.h b/include/system/types.h
+index 645c2df..d0259ba 100644
+--- a/include/system/types.h
++++ b/include/system/types.h
+@@ -9,6 +9,7 @@ __BEGIN_API
+ 
+ // Memory allocators
+ enum System_Allocator { SYSTEM };
++enum Shared_Allocator { SHARED };
+ enum Scratchpad_Allocator { SCRATCHPAD };
+ enum Color {
+     COLOR_0,  COLOR_1,  COLOR_2,  COLOR_3,  COLOR_4,  COLOR_5,  COLOR_6,  COLOR_7,
+@@ -44,6 +45,9 @@ inline void * operator new[](size_t s, void * a) { return a; }
+ void * operator new(size_t, const EPOS::System_Allocator &);
+ void * operator new[](size_t, const EPOS::System_Allocator &);
+ 
++void * operator new(size_t, const EPOS::Shared_Allocator &);
++void * operator new[](size_t, const EPOS::Shared_Allocator &);
++
+ void * operator new(size_t, const EPOS::Scratchpad_Allocator &);
+ void * operator new[](size_t, const EPOS::Scratchpad_Allocator &);
+ 
+diff --git a/include/utility/fork.h b/include/utility/fork.h
+new file mode 100644
+index 0000000..c125dda
+--- /dev/null
++++ b/include/utility/fork.h
+@@ -0,0 +1,44 @@
++#ifndef __fork_h
++#define __fork_h
++
++#include <process.h>
++#include <architecture.h>
++
++__BEGIN_UTIL
++
++static unsigned int fork(int(* main)()) {
++    //unsigned long lr = CPU::lr();
++    Task * c_task = Task::self();
++
++    // Code
++    Segment* cs;
++    unsigned int cs_size = c_task->code_segment()->size();
++    cs = new (SYSTEM) Segment(cs_size, Segment::Flags::SYS);
++
++    CPU::int_disable();
++    CPU::Log_Addr tmp = c_task->address_space()->attach(cs);
++    memcpy(tmp, c_task->code(), cs_size);
++    c_task->address_space()->detach(cs);
++    CPU::int_enable();
++
++    // Data
++    Segment* ds;
++    unsigned int ds_size = c_task->data_segment()->size();
++    ds = new (SYSTEM) Segment(ds_size, Segment::Flags::SYS);
++
++    CPU::int_disable();
++    CPU::Log_Addr tmp_ds = c_task->address_space()->attach(ds);
++    memcpy(tmp_ds, c_task->data(), ds_size);
++    c_task->address_space()->detach(ds);
++    CPU::int_enable();
++
++    typedef int (Main)();
++    main = reinterpret_cast<Main *>(main);
++    new (SYSTEM) Task(cs, ds, main, c_task->code(), c_task->data());
++
++    return Task::self()->id();
++}
++
++__END_UTIL
++
++#endif
+\ No newline at end of file
+diff --git a/makedefs b/makedefs
+index 8ed5c1d..8f8877f 100644
+--- a/makedefs
++++ b/makedefs
+@@ -147,7 +147,7 @@ ifeq ($(ARCH),armv7)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
+ cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+ else
+-cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes
++cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes -Wno-error=stringop-overflow -mgeneral-regs-only
+ ifeq ($(SMOD), library)
+ cortex_EMULATOR		= qemu-system-aarch64 -M raspi3 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+ else
+@@ -156,7 +156,7 @@ endif
+ endif
+ cortex_AS_FLAGS		:= -mcpu=cortex-a53
+ cortex_LD_FLAGS		:=
+-cortex_DEBUGGER		:= gdb
++cortex_DEBUGGER		:= aarch64-linux-gnu-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --nmagic
+ cortex_CODE_NAME	:= .init
+diff --git a/src/api/task.cc b/src/api/task.cc
+new file mode 100644
+index 0000000..1a188d9
+--- /dev/null
++++ b/src/api/task.cc
+@@ -0,0 +1,27 @@
++// EPOS Task Implementation
++
++#include <process.h>
++
++__BEGIN_SYS
++
++// Class attributes
++volatile unsigned int Task::_task_count;
++Task* volatile Task::_current;
++
++// Methods
++Task::~Task()
++{
++    db<Task>(TRC) << "~Task(this=" << this << ")" << endl;
++
++    while (!_threads.empty()){
++        delete _threads.remove()->object();
++    }
++
++    lock();
++    _task_count--;
++    unlock();
++
++    delete _as;
++}
++
++__END_SYS
+\ No newline at end of file
+diff --git a/src/api/thread.cc b/src/api/thread.cc
+index bf94c29..d82095f 100644
+--- a/src/api/thread.cc
++++ b/src/api/thread.cc
+@@ -88,6 +88,8 @@ Thread::~Thread()
+ 
+     if(_joining)
+         _joining->resume();
++    
++    _task->remove(this);
+ 
+     unlock();
+ 
+@@ -344,6 +346,10 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+         }
+         db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
+ 
++        if (prev->_task != next->_task) {
++            next->_task->activate_context();
++        }
++
+         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
+         // and necessary because of context switches, but here, we are locked() and
+         // passing the volatile to switch_constext forces it to push prev onto the stack,
+diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
+index e25ab96..8923f22 100644
+--- a/src/api/thread_init.cc
++++ b/src/api/thread_init.cc
+@@ -13,8 +13,6 @@ void Thread::init()
+ {
+     db<Init, Thread>(TRC) << "Thread::init()" << endl;
+ 
+-    Criterion::init();
+-
+     typedef int (Main)();
+ 
+     System_Info * si = System::info();
+@@ -27,7 +25,19 @@ void Thread::init()
+         // In this case, _init will have already been called, before Init_Application to construct MAIN's global objects.
+         main = reinterpret_cast<Main *>(__epos_app_entry);
+ 
+-    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
++    Criterion::init();
++
++    if (Traits<System>::multitask) {
++        Address_Space* as = new (SYSTEM) Address_Space(MMU::current());
++        Segment* cs = new (SYSTEM) Segment(Log_Addr(si->lm.app_code), si->lm.app_code_size, Segment::Flags::APPC);
++        Segment* ds = new (SYSTEM) Segment(Log_Addr(si->lm.app_data), si->lm.app_data_size, Segment::Flags::APPD);
++        Log_Addr code = si->lm.app_code;
++        Log_Addr data = si->lm.app_data;
++        new (SYSTEM) Task(as, cs, ds, main, code, data);
++    }
++    else {
++        new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(main));
++    }
+ 
+     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
+     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+@@ -48,4 +58,4 @@ void Thread::init()
+     This_Thread::not_booting();
+ }
+ 
+-__END_SYS
++__END_SYS
+\ No newline at end of file
+diff --git a/src/init/init_system.cc b/src/init/init_system.cc
+index fefda22..b12fcf3 100644
+--- a/src/init/init_system.cc
++++ b/src/init/init_system.cc
+@@ -32,6 +32,20 @@ public:
+             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+         db<Init>(INF) << "done!" << endl;
+ 
++        ///////////////////////////////
++
++        // If the trait sharedmemory is true, a segment with the same size of
++        // the system's heap will be allocated to be shared
++        db<Init>(INF) << "Initializing shared memory:" << endl;
++        if(Traits<System>::sharedmemory) {
++            Shared_Memory::_shared_heap_segment = new(&Shared_Memory::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SHR);
++            Shared_Memory::_shared_heap = new(&Shared_Memory::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Shared_Memory::_shared_heap_segment), Shared_Memory::_shared_heap_segment->size());
++        }
++        db<Init>(INF)<<"done!"<<endl;
++
++        ///////////////////////////////
++
++
+         db<Init>(INF) << "Initializing the machine: " << endl;
+         Machine::init();
+         db<Init>(INF) << "done!" << endl;
+diff --git a/src/machine/cortex/cortex_ic.cc b/src/machine/cortex/cortex_ic.cc
+index 3c72071..7f6e987 100644
+--- a/src/machine/cortex/cortex_ic.cc
++++ b/src/machine/cortex/cortex_ic.cc
+@@ -129,6 +129,54 @@ extern "C" { void _dispatch(unsigned int) __attribute__ ((alias("_ZN4EPOS1S2IC8d
+ 
+ void IC::entry()
+ {
++    // str: store register
++    // stp: store pair
++    // mrs: move the contents of a PSR to a general-purpose register
++    // ldr: load register
++    // ldp: load pair
++    ASM("str        x30, [sp, # -8]!                                     \t\n\
++         stp   x28, x29, [sp, #-16]!                                     \t\n\
++         stp   x26, x27, [sp, #-16]!                                     \t\n\
++         stp   x24, x25, [sp, #-16]!                                     \t\n\
++         stp   x22, x23, [sp, #-16]!                                     \t\n\
++         stp   x20, x21, [sp, #-16]!                                     \t\n\
++         stp   x18, x19, [sp, #-16]!                                     \t\n\
++         stp   x16, x17, [sp, #-16]!                                     \t\n\
++         stp   x14, x15, [sp, #-16]!                                     \t\n\
++         stp   x12, x13, [sp, #-16]!                                     \t\n\
++         stp   x10, x11, [sp, #-16]!                                     \t\n\
++         stp    x8,  x9, [sp, #-16]!                                     \t\n\
++         stp    x6,  x7, [sp, #-16]!                                     \t\n\
++         stp    x4,  x5, [sp, #-16]!                                     \t\n\
++         stp    x2,  x3, [sp, #-16]!                                     \t\n\
++         stp    x0,  x1, [sp, #-16]!                                     \t\n\
++         mrs x30, elr_el1                                                \t\n\
++         str        x30, [sp, # -8]!                                     \t\n\
++         mrs x30, spsr_el1                                               \t\n\
++         str        x30, [sp, # -8]!                                     \t" : : : "cc");
++
++    dispatch(int_id());
++
++    ASM("ldr         x30, [sp], #8                                       \t\n\
++         msr  spsr_el1, x30                                              \t\n\
++         ldr         x30, [sp], #8                                       \t\n\
++         msr  elr_el1, x30                                               \t\n\
++         ldp    x0,  x1, [sp], #16                                       \t\n\
++         ldp    x2,  x3, [sp], #16                                       \t\n\
++         ldp    x4,  x5, [sp], #16                                       \t\n\
++         ldp    x6,  x7, [sp], #16                                       \t\n\
++         ldp    x8,  x9, [sp], #16                                       \t\n\
++         ldp   x10, x11, [sp], #16                                       \t\n\
++         ldp   x12, x13, [sp], #16                                       \t\n\
++         ldp   x14, x15, [sp], #16                                       \t\n\
++         ldp   x16, x17, [sp], #16                                       \t\n\
++         ldp   x18, x19, [sp], #16                                       \t\n\
++         ldp   x20, x21, [sp], #16                                       \t\n\
++         ldp   x22, x23, [sp], #16                                       \t\n\
++         ldp   x24, x25, [sp], #16                                       \t\n\
++         ldp   x26, x27, [sp], #16                                       \t\n\
++         ldp   x28, x29, [sp], #16                                       \t\n\
++         ldr        x30, [sp], #8                                        \t" : : : "cc");
+ }
+ 
+ #endif    
+diff --git a/src/setup/setup_raspberry_pi3.cc b/src/setup/setup_raspberry_pi3.cc
+index e929cba..1cd581a 100644
+--- a/src/setup/setup_raspberry_pi3.cc
++++ b/src/setup/setup_raspberry_pi3.cc
+@@ -1050,140 +1050,216 @@ void _vector_table()
+     // Therefore, each exception level maps the four exception type handlers aligned by 128 bytes (enough room to write simple handlers).
+ 
+     // Our strategy is to forward all interrupts to _int_entry via
+-    ASM("// Current EL with SP0                                                 \t\n\
++    ASM("                                                                       \t\n\
+                         .balign 128                                             \t\n\
+         .sync_curr_sp0: str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_sync_curr_sp0                               \t\n\
++                        mov x0, #0                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0,  [sp], #8                                       \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .irq_curr_sp0:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_irq_curr_sp0                                \t\n\
++                        mov x0, #0                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0,  [sp], #8                                       \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .fiq_curr_sp0:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_fiq_curr_sp0                                \t\n\
++                        mov x0, #0                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0,  [sp], #8                                       \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .error_curr_sp0:str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_error_curr_sp0                              \t\n\
++                        mov x0, #0                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                         ldr x0,  [sp], #8                                      \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+-        // Current EL with SPx                                                  \t\n\
+                         .balign 128                                             \t\n\
+         .sync_curr_spx: str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_sync_curr_spx                               \t\n\
++                        mov x0, #4                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .irq_curr_spx:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_irq_curr_spx                                \t\n\
++                        mov x0, #4                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .fiq_curr_spx:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_fiq_curr_spx                                \t\n\
++                        mov x0, #4                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .error_curr_spx:str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0,  [sp,#-8]!                                      \t\n\
++                        ldr x29, vj_error_curr_spx                              \t\n\
++                        mov x0, #4                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+         // Lower EL using AArch64                                               \t\n\
+                         .balign 128                                             \t\n\
+         .sync_lower64:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
+-                        blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        str x28, [sp,#-8]!                                      \t\n\
++                        mrs x28, CurrentEL                                      \t\n\
++                        and x28, x28, #12                                       \t\n\
++                        lsr x28, x28, #2                                        \t\n\
++                                                                                \t\n\
++                        cmp x28, #2                                             \t\n\
++                        beq .1                                                  \t\n\
++                        ldr x29, vj_sync_lower64                                \t\n\
++                        b .2                                                    \t\n\
++                    .1:                                                         \t\n\
++                        dsb   ishst                                             \t\n\
++                        tlbi  alle1                                             \t\n\
++                        dsb   ish                                               \t\n\
++                        isb                                                     \t\n\
++                    .2:                                                         \t\n\
++                        ldr x28, [sp], #8                                       \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .irq_lower64:   str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_irq_lower64                                 \t\n\
++                        mov x0, #9                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .fiq_lower64:   str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_fiq_lower64                                 \t\n\
++                        mov x0, #9                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .error_lower64: str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_serr_lower64                                \t\n\
++                        mov x0, #9                                              \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         // Lower EL using AArch32                               \t\n\
+                         .balign 128                                             \t\n\
+         .sync_lower32:  str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_sync_lower32                                \t\n\
++                        mov x0, #12                                             \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .irq_lower32:   str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_irq_lower32                                 \t\n\
++                        mov x0, #12                                             \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+         .fiq_lower32:   str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_fiq_lower32                                 \t\n\
++                        mov x0, #12                                             \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
++                                                                                \t\n\
+         .error_lower32: str x30, [sp,#-8]!                                      \t\n\
+                         str x29, [sp,#-8]!                                      \t\n\
+-                        ldr x29, .ic_entry                                      \t\n\
++                        str x0, [sp, #-8]!                                      \t\n\
++                        ldr x29, vj_serr_lower32                                \t\n\
++                        mov x0, #12                                             \t\n\
+                         blr x29                                                 \t\n\
+-                        ldr x30, [sp], #8                                       \t\n\
++                        ldr x0, [sp], #8                                        \t\n\
++                        ldp  x29, x30, [sp], #16                                \t\n\
+                         eret                                                    \t\n\
+                                                                                 \t\n\
+                         .balign 128                                             \t\n\
+-        .ic_entry: .dword 0x0                                                   \t");
++        .global _vector_jat                                                     \t\n\
++        _vector_jat:                                                            \t\n\
++        vj_sync_curr_sp0:       .dword 0x0                                      \t\n\
++        vj_irq_curr_sp0:        .dword 0x0                                      \t\n\
++        vj_fiq_curr_sp0:        .dword 0x0                                      \t\n\
++        vj_error_curr_sp0:      .dword 0x0                                      \t\n\
++        vj_sync_curr_spx:       .dword 0x0                                      \t\n\
++        vj_irq_curr_spx:        .dword 0x0                                      \t\n\
++        vj_fiq_curr_spx:        .dword 0x0                                      \t\n\
++        vj_error_curr_spx:      .dword 0x0                                      \t\n\
++        vj_sync_lower64:        .dword 0x0                                      \t\n\
++        vj_irq_lower64:         .dword 0x0                                      \t\n\
++        vj_fiq_lower64:         .dword 0x0                                      \t\n\
++        vj_serr_lower64:        .dword 0x0                                      \t\n\
++        vj_sync_lower32:        .dword 0x0                                      \t\n\
++        vj_irq_lower32:         .dword 0x0                                      \t\n\
++        vj_fiq_lower32:         .dword 0x0                                      \t\n\
++        vj_serr_lower32:        .dword 0x0                                      \t");
+ }
+ 
+ void _reset()
+diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
+index 941d0d0..147cca2 100644
+--- a/src/system/system_scaffold.cc
++++ b/src/system/system_scaffold.cc
+@@ -21,6 +21,9 @@ System_Info * System::_si = (Memory_Map::SYS_INFO != Memory_Map::NOT_USED) ? rei
+ char System::_preheap[];
+ Segment * System::_heap_segment;
+ Heap * System::_heap;
++char Shared_Memory::_preheap[];
++Segment * Shared_Memory:: _shared_heap_segment;
++Heap * Shared_Memory:: _shared_heap;
+ 
+ __END_SYS
+ 
diff --git a/e6b.diff b/e6b.diff
new file mode 100644
index 0000000..e69de29
diff --git a/e7b.diff b/e7b.diff
new file mode 100644
index 0000000..c5e96e1
--- /dev/null
+++ b/e7b.diff
@@ -0,0 +1,941 @@
+diff --git a/Dockerfile b/Dockerfile
+new file mode 100644
+index 0000000..33be31f
+--- /dev/null
++++ b/Dockerfile
+@@ -0,0 +1,51 @@
++FROM ubuntu:focal
++
++WORKDIR /home
++
++ENV TZ=America/Sao_Paulo
++RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ
++
++RUN apt-get update && \
++    apt-get install -y \
++        bc \
++        bin86 \
++        build-essential \
++        g++-multilib \
++        gcc-multilib \
++        gdb \
++        gdb-multiarch \
++        make \
++        python3 \
++        python3-pip \
++        qemu \
++        qemu-kvm \
++        qemu-system-arm \
++        tar \
++        tcsh \
++        wget \
++        xterm && \
++    apt-get clean && \
++    rm -rf /var/lib/apt/lists/*
++
++RUN wget https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init_1.2.2_amd64.deb && \
++    dpkg -i dumb-init_*.deb && \
++    rm dumb-init_*.deb
++
++RUN wget -q -O ia32.tar.gz https://epos.lisha.ufsc.br/dl469 && \
++    tar -zxvf ia32.tar.gz && \
++    mkdir -p /usr/local/ia32/ && \
++    mv gcc-7.2.0 /usr/local/ia32/ && \
++    rm -r ia32.tar.gz
++
++RUN wget -q -O arm.tar.gz https://epos.lisha.ufsc.br/dl468 && \
++    tar -zxvf arm.tar.gz && \
++    mkdir -p /usr/local/arm/ && \
++    mv gcc-7.2.0 /usr/local/arm/ && \
++    rm -r arm.tar.gz
++
++ENV PATH="${PATH}:/usr/local/arm/gcc-7.2.0/bin/"
++
++VOLUME /code
++WORKDIR /code
++
++ENTRYPOINT ["/usr/bin/dumb-init", "--"]
+diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
+index 77a3de8..512cac1 100644
+--- a/app/hello/hello_traits.h
++++ b/app/hello/hello_traits.h
+@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
+     static const bool multitask = (mode != Traits<Build>::LIBRARY);
+     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool sharedmemory = true;
+ 
+     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+     static const unsigned int DUTY_CYCLE = 1000000; // ppm
+diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
+index 77a3de8..512cac1 100644
+--- a/app/philosophers_dinner/philosophers_dinner_traits.h
++++ b/app/philosophers_dinner/philosophers_dinner_traits.h
+@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
+     static const bool multitask = (mode != Traits<Build>::LIBRARY);
+     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool sharedmemory = true;
+ 
+     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+     static const unsigned int DUTY_CYCLE = 1000000; // ppm
+diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
+index 77a3de8..512cac1 100644
+--- a/app/producer_consumer/producer_consumer_traits.h
++++ b/app/producer_consumer/producer_consumer_traits.h
+@@ -107,6 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
+     static const bool multitask = (mode != Traits<Build>::LIBRARY);
+     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+     static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool sharedmemory = true;
+ 
+     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+     static const unsigned int DUTY_CYCLE = 1000000; // ppm
+diff --git a/app/test_deadline/makefile b/app/test_deadline/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test_deadline/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test_deadline/test_deadline.cc b/app/test_deadline/test_deadline.cc
+new file mode 100644
+index 0000000..9508a9e
+--- /dev/null
++++ b/app/test_deadline/test_deadline.cc
+@@ -0,0 +1,43 @@
++#include <utility/ostream.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++int testing();
++
++int main()
++{
++    Periodic_Thread::Configuration conf_a{5000, 1000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++    Periodic_Thread::Configuration conf_b{1500, 500, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++    Periodic_Thread::Configuration conf_c{25000, 5000, Periodic_Thread::SAME, Periodic_Thread::UNKNOWN, 10, Thread::READY, Periodic_Thread::NORMAL, 16 * 1024};
++
++    Periodic_Thread * a = new Periodic_Thread(conf_a, &testing);
++    Periodic_Thread * b = new Periodic_Thread(conf_b, &testing);
++    Periodic_Thread * c = new Periodic_Thread(conf_c, &testing);
++
++    a -> join();
++    b -> join();
++    c -> join();
++
++
++    delete a;
++    delete b;
++    delete c;
++
++    cout << "Finishing test..." << endl;
++
++    return 0;
++}
++
++int testing() {
++  int i = 0;
++  while ((i < 10) and Periodic_Thread::wait_next()) // iterator stops infinite runs.
++  {
++    cout << "Job finished\n" << endl;
++    i++;
++  }
++
++  return 0;
++}
+\ No newline at end of file
+diff --git a/app/test_deadline/test_deadline_traits.h b/app/test_deadline/test_deadline_traits.h
+new file mode 100644
+index 0000000..2805c20
+--- /dev/null
++++ b/app/test_deadline/test_deadline_traits.h
+@@ -0,0 +1,159 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = ARMv7;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = false;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = false;
++    static const bool info    = false;
++    static const bool trace   = true;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef DM Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++template<> struct Traits<DM>: public Traits<Build>
++{
++    static const bool debugged = true;
++};
++
++__END_SYS
++
++#endif
+diff --git a/app/test_shared_memory/makefile b/app/test_shared_memory/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test_shared_memory/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test_shared_memory/test_shared_memory.cc b/app/test_shared_memory/test_shared_memory.cc
+new file mode 100644
+index 0000000..5d4a190
+--- /dev/null
++++ b/app/test_shared_memory/test_shared_memory.cc
+@@ -0,0 +1,77 @@
++#include <utility/ostream.h>
++#include <process.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++
++char * test_char = new (SHARED) char('a');
++
++int test1_b() {
++    *test_char = 'b';
++    return 0;
++}
++
++int test1_c() {
++    *test_char = 'c';
++    return 0;
++}
++
++int main() {
++
++    cout << "-----------------------" << endl;
++    cout << "Shared memory test" << endl;
++    cout << "-----------------------" << endl;
++
++    // Test 1: create a global variable in the shared memory 
++    // and manipulate it with two different threads
++    Thread * test1_b_thread = new Thread(&test1_b);
++    Thread * test1_c_thread = new Thread(&test1_c);
++
++    test1_b_thread->join();
++    test1_c_thread->join();
++
++    cout << "Asserting test char value" << endl;
++    assert(*test_char != 'a');
++    assert(*test_char != 'b');
++    assert(*test_char == 'c');
++
++    delete test_char;
++
++    // Test 2: after deleting a variable from the shared memory,
++    // create another one and change it's value
++    int * test_int = new (SHARED) int;
++    *test_int = 0;
++    *test_int += 1;
++
++    cout << "Asserting test int value" << endl;
++    assert(*test_int != 0);
++    assert(*test_int == 1);
++    assert(*test_int != 2);
++
++    delete test_int;
++
++    // Test 3: create and change the value of a variable in the
++    // system, application and shared heap
++
++    cout << "Asserting variables in different heaps" << endl;
++
++    int * test_shared_var = new (SHARED) int;
++    int * test_system_var = new (SYSTEM) int;
++    int * test_application_var = new int;
++    
++    *test_shared_var = 0;
++    *test_system_var = 1;
++    *test_application_var = 2;
++
++    ++*test_shared_var;
++    ++*test_system_var;
++    ++*test_application_var;
++
++    assert(*test_shared_var == 1);
++    assert(*test_system_var == 2);
++    assert(*test_application_var == 3);
++    
++    cout << "Finishing test..." << endl;
++}
+\ No newline at end of file
+diff --git a/app/test_shared_memory/test_shared_memory_traits.h b/app/test_shared_memory/test_shared_memory_traits.h
+new file mode 100644
+index 0000000..b5e047e
+--- /dev/null
++++ b/app/test_shared_memory/test_shared_memory_traits.h
+@@ -0,0 +1,156 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = ARMv7;
++    static const unsigned int MACHINE = Cortex;
++    static const unsigned int MODEL = Raspberry_Pi3;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = true;
++    static const bool sharedmemory = true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef DM Criterion;
++    static const bool preemptive = true;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/dockepos b/dockepos
+new file mode 100644
+index 0000000..7f801ce
+--- /dev/null
++++ b/dockepos
+@@ -0,0 +1,10 @@
++#! /bin/bash
++
++docker run -it --rm \
++-v $(pwd):/code \
++-v "/tmp/.X11-unix:/tmp/.X11-unix:rw" \
++-e "DISPLAY" \
++-e 'QEMU_AUDIO_DRV=none' \
++-u $(id -u):$(id -g) \
++pico/dockepos \
++$@
+diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
+index 17ea7d9..c3c4511 100644
+--- a/include/architecture/mmu.h
++++ b/include/architecture/mmu.h
+@@ -50,6 +50,7 @@ public:
+             IO   = 1 << 8, // Memory Mapped I/O (0=memory, 1=I/O)
+             SYS  = (PRE | RD | RW | EX),
+             APP  = (PRE | RD | RW | EX | USR),
++            SHR  = (PRE | RD | RW | EX | USR),
+             APPC = (PRE | RD | EX | USR),
+             APPD = (PRE | RD | RW | USR)
+         };
+diff --git a/include/real-time.h b/include/real-time.h
+index 4f53875..e5559fd 100644
+--- a/include/real-time.h
++++ b/include/real-time.h
+@@ -25,13 +25,14 @@ typedef Thread Aperiodic_Thread;
+ class Periodic_Thread: public Thread
+ {
+ public:
+-    enum {
+-        SAME    = Real_Time_Scheduler_Common::SAME,
+-        NOW     = Real_Time_Scheduler_Common::NOW,
+-        UNKNOWN = Real_Time_Scheduler_Common::UNKNOWN,
+-        ANY     = Real_Time_Scheduler_Common::ANY
++    enum : unsigned int {
++        SAME    = 0,
++        NOW     = 0,
++        UNKNOWN = 0,
++        ANY     = -1U
+     };
+ 
++
+ protected:
+     // Alarm Handler for periodic threads under static scheduling policies
+     class Static_Handler: public Semaphore_Handler
+@@ -75,7 +76,12 @@ public:
+ public:
+     template<typename ... Tn>
+     Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+-    : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
++    : Thread(Thread::Configuration(SUSPENDED, Criterion(p, p)), entry, an ...),
++      _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
++
++    template<typename ... Tn>
++    Periodic_Thread(const Microsecond & p, const Microsecond d, int (* entry)(Tn ...), Tn ... an)
++    : Thread(Thread::Configuration(SUSPENDED, Criterion(d, p)), entry, an ...),
+       _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+ 
+     template<typename ... Tn>
+@@ -96,6 +102,7 @@ public:
+         Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+ 
+         db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
++        db<DM> (TRC) << "Thread " << t << " started working. Period: " << t->criterion() << endl;
+ 
+         if(t->_alarm.times())
+             t->_semaphore.p();
+diff --git a/include/scheduler.h b/include/scheduler.h
+index 99bfd36..e86be96 100644
+--- a/include/scheduler.h
++++ b/include/scheduler.h
+@@ -145,6 +145,38 @@ public:
+     FCFS(int p = NORMAL, Tn & ... an);
+ };
+ 
++class Real_Time_Scheduler: public Priority
++{
++protected:
++    Real_Time_Scheduler(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {}
++    Real_Time_Scheduler(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
++    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
++
++public:
++    const Microsecond period() { return _period; }
++    void period(const Microsecond & p) { _period = p; }
++
++public:
++    Microsecond _deadline;
++    Microsecond _period;
++    Microsecond _capacity;
++};
++
++// Deadline Monotonic
++class DM: public Real_Time_Scheduler
++{
++
++public:
++    static const bool timed = false;
++    static const bool dynamic = false;
++    static const bool preemptive = true;
++
++public:
++    DM(int p = APERIODIC): Real_Time_Scheduler(p) {}
++    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
++    : Real_Time_Scheduler(d, d, p, c) {}
++};
++
+ __END_SYS
+ 
+-#endif
++#endif
+\ No newline at end of file
+diff --git a/include/system.h b/include/system.h
+index 5215ef1..63b03e8 100644
+--- a/include/system.h
++++ b/include/system.h
+@@ -47,13 +47,29 @@ private:
+     static char _preheap[(Traits<System>::multiheap ? sizeof(Segment) : 0) + sizeof(Heap)];
+     static Segment * _heap_segment;
+     static Heap * _heap;
++    static Segment * _shared_segment;
++};
++
++// Class used to store and handle the shared memory heap with the "new (SHARED)" operator
++class Shared_Memory {
++    friend class Init_System;
++    friend void * ::malloc(size_t);
++    friend void ::free(void*);
++    friend void * ::operator new(size_t, const EPOS::Shared_Allocator&);
++    friend void * ::operator new[](size_t, const EPOS::Shared_Allocator&);
++    friend void ::operator delete(void*);
++    friend void ::operator delete[](void*);
++
++    private:
++    static char _preheap[sizeof(Segment) + sizeof(Heap)];
++    static Segment * _shared_heap_segment;
++    static Heap * _shared_heap;
+ };
+ 
+ __END_SYS
+ 
+ extern "C"
+ {
+-    // Standard C Library allocators
+     inline void * malloc(size_t bytes) {
+         __USING_SYS;
+         if(Traits<System>::multiheap)
+@@ -94,6 +110,14 @@ inline void * operator new[](size_t bytes, const EPOS::System_Allocator & alloca
+     return _SYS::System::_heap->alloc(bytes);
+ }
+ 
++inline void * operator new(size_t bytes, const EPOS::Shared_Allocator & allocator) {
++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
++}
++
++inline void * operator new[](size_t bytes, const EPOS::Shared_Allocator & allocator) {
++    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
++}
++
+ // Delete cannot be declared inline due to virtual destructors
+ void operator delete(void * ptr);
+ void operator delete[](void * ptr);
+diff --git a/include/system/traits.h b/include/system/traits.h
+index 5e505ed..7aeb447 100644
+--- a/include/system/traits.h
++++ b/include/system/traits.h
+@@ -93,6 +93,7 @@ class Keypad;
+ // API Components
+ class System;
+ class Application;
++class Shared_Memory;
+ 
+ class Thread;
+ class Active;
+diff --git a/include/system/types.h b/include/system/types.h
+index 645c2df..d0259ba 100644
+--- a/include/system/types.h
++++ b/include/system/types.h
+@@ -9,6 +9,7 @@ __BEGIN_API
+ 
+ // Memory allocators
+ enum System_Allocator { SYSTEM };
++enum Shared_Allocator { SHARED };
+ enum Scratchpad_Allocator { SCRATCHPAD };
+ enum Color {
+     COLOR_0,  COLOR_1,  COLOR_2,  COLOR_3,  COLOR_4,  COLOR_5,  COLOR_6,  COLOR_7,
+@@ -44,6 +45,9 @@ inline void * operator new[](size_t s, void * a) { return a; }
+ void * operator new(size_t, const EPOS::System_Allocator &);
+ void * operator new[](size_t, const EPOS::System_Allocator &);
+ 
++void * operator new(size_t, const EPOS::Shared_Allocator &);
++void * operator new[](size_t, const EPOS::Shared_Allocator &);
++
+ void * operator new(size_t, const EPOS::Scratchpad_Allocator &);
+ void * operator new[](size_t, const EPOS::Scratchpad_Allocator &);
+ 
+diff --git a/include/time.h b/include/time.h
+index 8608ce0..7b7d168 100644
+--- a/include/time.h
++++ b/include/time.h
+@@ -34,6 +34,7 @@ class Alarm
+     friend class Alarm_Chronometer;             // for elapsed()
+     friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
+     friend class FCFS;                          // for ticks() and elapsed()
++    friend class DM;
+ 
+ private:
+     typedef Timer_Common::Tick Tick;
+
+diff --git a/makedefs b/makedefs
+index 09760e0..9dd2176 100644
+--- a/makedefs
++++ b/makedefs
+@@ -93,8 +93,8 @@ UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g
+ 
+ # Compiler prefixes
+ ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
+-armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
+-armv8_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
++armv7_COMP_PREFIX       := /usr/local/arm/gcc-7.2.0/bin/arm-
++armv8_COMP_PREFIX       := /usr/local/arm/gcc-7.2.0/bin/arm-
+ rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+ rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
+ COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
+@@ -116,11 +116,11 @@ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+ cortex_LD_FLAGS		:=
+ cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+-cortex_DEBUGGER		:= arm-none-eabi-gdb
++cortex_DEBUGGER		:= gdb-multiarch
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+ cortex_CODE_NAME	:= .init
+-cortex_DATA_NAME	:= .data
++cortex_DATA_NAME	:=
+ cortex_IMG_SUFFIX	:= .bin
+ endif
+ 
+@@ -128,11 +128,11 @@ ifeq ($(MMOD),zynq)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+ cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+-cortex_DEBUGGER		:= arm-none-eabi-gdb
++cortex_DEBUGGER		:= gdb-multiarch
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+ cortex_CODE_NAME	:= .init
+-cortex_DATA_NAME	:= .data
++cortex_DATA_NAME	:=
+ cortex_IMG_SUFFIX	:= .bin
+ endif
+ 
+@@ -140,12 +140,12 @@ ifeq ($(MMOD),raspberry_pi3)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
+ cortex_AS_FLAGS		:= -mcpu=cortex-a53
+ cortex_LD_FLAGS		:=
+-cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -device loader,file=$(APPLICATION).img,addr=$(IMAGE_ADDR),force-raw=on -kernel 
+-cortex_DEBUGGER		:= gdb
++cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_DEBUGGER		:= gdb-multiarch
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+-cortex_MAGIC		:= --nmagic
++cortex_MAGIC		:= --omagic
+ cortex_CODE_NAME	:= .init
+-cortex_DATA_NAME	:= .data
++cortex_DATA_NAME	:=
+ cortex_IMG_SUFFIX	:= .bin
+ endif
+ 
+@@ -154,7 +154,7 @@ cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial m
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+-cortex_DEBUGGER		:= arm-none-eabi-gdb
++cortex_DEBUGGER		:= gdb-multiarch
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+ cortex_CODE_NAME	:= .init
+@@ -167,7 +167,7 @@ cortex_EMULATOR		=
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+-cortex_DEBUGGER		:= arm-none-eabi-gdb
++cortex_DEBUGGER		:= gdb-multiarch
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+ cortex_CODE_NAME	:= .init
+@@ -315,7 +315,7 @@ TEE		:= tee
+ ifndef DISPLAY
+ TERM        := sh -c
+ else
+-TERM        := konsole -e
++TERM        := xterm -e
+ endif
+ 
+ TOUCH		:= touch
+diff --git a/src/init/init_system.cc b/src/init/init_system.cc
+index fefda22..194f864 100644
+--- a/src/init/init_system.cc
++++ b/src/init/init_system.cc
+@@ -32,6 +32,19 @@ public:
+             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+         db<Init>(INF) << "done!" << endl;
+ 
++        ///////////////////////////////
++
++        // If the trait sharedmemory is true, a segment with the same size of
++        // the system's heap will be allocated to be shared
++        db<Init>(INF) << "Initializing shared memory:" << endl;
++        if(Traits<System>::sharedmemory) {
++            Shared_Memory::_shared_heap_segment = new(&Shared_Memory::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SHR);
++            Shared_Memory::_shared_heap = new(&Shared_Memory::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Shared_Memory::_shared_heap_segment), Shared_Memory::_shared_heap_segment->size());
++        }
++        db<Init>(INF)<<"done!"<<endl;
++
++        ///////////////////////////////
++
+         db<Init>(INF) << "Initializing the machine: " << endl;
+         Machine::init();
+         db<Init>(INF) << "done!" << endl;
+diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
+index 93089ce..0599311 100644
+--- a/src/system/system_scaffold.cc
++++ b/src/system/system_scaffold.cc
+@@ -19,6 +19,9 @@ System_Info * System::_si = reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO
+ char System::_preheap[];
+ Segment * System::_heap_segment;
+ Heap * System::_heap;
++char Shared_Memory::_preheap[];
++Segment * Shared_Memory:: _shared_heap_segment;
++Heap * Shared_Memory:: _shared_heap;
+ 
+ __END_SYS
+ 
\ No newline at end of file
diff --git a/include/architecture/armv8/armv8_cpu.h b/include/architecture/armv8/armv8_cpu.h
index e063d5e..4484477 100644
--- a/include/architecture/armv8/armv8_cpu.h
+++ b/include/architecture/armv8/armv8_cpu.h
@@ -349,7 +349,10 @@ public:
     static Reg  pd() { return ttbr0(); }
     static void pd(Reg r) {  ttbr0(r); }
 
-    static void flush_tlb();
+   static void flush_tlb() {
+       db<MMU>(TRC) << "CPU::flush_tlb() " << endl;
+       ASM("hvc #0                                   \t\n");
+   }
     static void flush_tlb(Reg r);
 
     static void flush_branch_predictors();
@@ -431,10 +434,51 @@ public:
     {
     public:
         Context() {}
-        Context(Log_Addr entry, Log_Addr exit, Log_Addr usp): Base::Context(entry, exit, 0) {}
+        Context(Log_Addr  entry, Log_Addr exit, Log_Addr usp, bool is_system):_usp(usp), _flags((is_system? FLAG_SVC : FLAG_SVC)), _lr(exit | (thumb ? 1 : 0)), _pc(entry | (thumb ? 1 : 0)) {
+            if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
+                _x0 = 0; _x1 = 1; _x2 = 2; _x3 = 3; _x4 = 4; _x5 = 5; _x6 = 6; _x7 = 7; _x8 = 8; _x9 = 9; _x10 = 10; _x11 = 11; _x12 = 12; _x13 = 13; _x14 = 14; _x15 = 15;
+                _x16 = 16; _x17 = 17; _x18 = 18; _x19 = 19; _x20 = 20; _x21 = 21; _x22 = 22; _x23 = 23; _x24 = 24; _x25 = 25; _x26 = 26; _x27 = 27; _x28 = 28; _x29 = 29;
+            }
+        }
 
         void save() volatile;
         void load() const volatile;
+
+        public:
+            Reg64 _usp;
+            Reg64 _flags;
+            Reg64 _x0;
+            Reg64 _x1;
+            Reg64 _x2;
+            Reg64 _x3;
+            Reg64 _x4;
+            Reg64 _x5;
+            Reg64 _x6;
+            Reg64 _x7;
+            Reg64 _x8;
+            Reg64 _x9;
+            Reg64 _x10;
+            Reg64 _x11;
+            Reg64 _x12;
+            Reg64 _x13;
+            Reg64 _x14;
+            Reg64 _x15;
+            Reg64 _x16;
+            Reg64 _x17; 
+            Reg64 _x18;
+            Reg64 _x19;
+            Reg64 _x20;
+            Reg64 _x21;
+            Reg64 _x22;
+            Reg64 _x23;
+            Reg64 _x24;
+            Reg64 _x25;
+            Reg64 _x26;
+            Reg64 _x27;
+            Reg64 _x28;
+            Reg64 _x29;
+            Reg64 _lr;
+            Reg64 _pc;
     };
 
 public:
@@ -474,16 +518,20 @@ public:
     static void switch_context(Context ** o, Context * n);
 
     template<typename ... Tn>
-    static Context * init_stack(Log_Addr usp, Log_Addr sp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
-        sp -= sizeof(Context);
-        Context * ctx = new(sp) Context(entry, exit, usp); // init_stack is called with usp = 0 for kernel threads
+    static Context * init_stack(Log_Addr usp, Log_Addr ksp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
+        ksp -= sizeof(Context);
+        Context * ctx = new(ksp) Context(entry, exit, usp, true);
         init_stack_helper(&ctx->_x0, an ...);
         return ctx;
     }
 
-    // In ARMv8, the main thread of each task gets parameters over registers, not the stack, and they are initialized by init_stack.
     template<typename ... Tn>
-    static Log_Addr init_user_stack(Log_Addr usp, void (* exit)(), Tn ... an) { return usp; }
+    static Context * init_user_stack(Log_Addr usp, Log_Addr ksp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
+        ksp -= sizeof(Context);
+        Context * ctx = new(ksp) Context(entry, exit, usp, false);
+        init_stack_helper(&ctx->_x0, an ...);
+        return ctx;
+    }
 
     static void syscall(void * message);
     static void syscalled();
@@ -507,6 +555,35 @@ public:
     using CPU_Common::ntohl;
     using CPU_Common::ntohs;
 
+    // CPU Flags
+    typedef Reg64 Flags;
+    enum {
+        FLAG_M          = 0x1f << 0,       // Processor Mode (5 bits)
+        FLAG_T          = 1    << 5,       // Thumb state
+        FLAG_F          = 1    << 6,       // FIQ disable
+        FLAG_I          = 1    << 7,       // IRQ disable
+        FLAG_A          = 1    << 8,       // Imprecise Abort disable
+        FLAG_E          = 1    << 9,       // Endianess (0 ->> little, 1 -> big)
+        FLAG_GE         = 0xf  << 16,      // SIMD Greater than or Equal (4 bits)
+        FLAG_J          = 1    << 24,      // Jazelle state
+        FLAG_Q          = 1    << 27,      // Underflow and/or DSP saturation
+        FLAG_V          = 1    << 28,      // Overflow
+        FLAG_C          = 1    << 29,      // Carry
+        FLAG_Z          = 1    << 30,      // Zero
+        FLAG_N          = 1    << 31,      // Negative
+
+        // FLAG_M values
+        FLAG_USER       = 0x10,      // User mode
+        FLAG_FIQ        = 0x11,      // FIQ mode
+        FLAG_IRQ        = 0x12,      // IRQ mode
+        FLAG_SVC        = 0x13,      // SVC mode
+        FLAG_ABORT      = 0x17,      // Abort mode
+        FLAG_UNDEFINED  = 0x1b,      // Undefined mode
+        FLAG_SYSTEM     = 0x1f,      // System mode
+
+        FLAG_DEFAULTS   = FLAG_SVC
+    };
+
 private:
     template<typename Head, typename ... Tail>
     static void init_stack_helper(Log_Addr sp, Head head, Tail ... tail) {
diff --git a/include/architecture/armv8/armv8_mmu.h b/include/architecture/armv8/armv8_mmu.h
index d33def1..34ebfe3 100644
--- a/include/architecture/armv8/armv8_mmu.h
+++ b/include/architecture/armv8/armv8_mmu.h
@@ -158,7 +158,61 @@ template<unsigned int ENTRIES>
     typedef _Page_Table<PT_ENTRIES> Page_Table;
 
     // Page Directory
-    typedef _Page_Table<PD_ENTRIES> Page_Directory;
+    class Page_Directory {
+    public:
+        Page_Directory() {}
+
+        PD_Entry & operator[](unsigned int i) { return _entry[i]; }
+        Page_Directory & log() { return *static_cast<Page_Directory *>(phy2log(this)); }
+
+        void map(int from, int to, Page_Flags flags, Color color) {
+            Phy_Addr * addr = alloc(to - from, color);
+            if(addr)
+                remap(addr, from, to, flags);
+            else
+                for( ; from < to; from++) {
+                    Log_Addr * pde = phy2log(&_entry[from]);
+                    *pde = phy2pde(alloc(1, color));
+                }
+        }
+
+        void map_contiguous(int from, int to, Page_Flags flags, Color color) {
+            remap(alloc(to - from, color), from, to, flags);
+        }
+
+        void remap(Phy_Addr addr, int from, int to, Page_Flags flags) {
+            addr = align_page(addr);
+            for( ; from < to; from++) {
+                Log_Addr * pde = phy2log(&_entry[from]);
+                *pde = phy2pde(addr);
+                addr += sizeof(Page);
+            }
+        }
+
+        void unmap(int from, int to) {
+            for( ; from < to; from++) {
+                free(_entry[from]);
+                Log_Addr * pde = phy2log(&_entry[from]);
+                *pde = 0;
+            }
+        }
+
+        friend OStream & operator<<(OStream & os, Page_Directory & pd) {
+            os << "{\n";
+            int brk = 0;
+            for(unsigned int i = 0; i < PD_ENTRIES; i++)
+                if(pd[i]) {
+                    os << "[" << i << "]=" << pd[i] << "  ";
+                    if(!(++brk % 4))
+                        os << "\n";
+                }
+            os << "\n}";
+            return os;
+        }
+
+    private:
+        PD_Entry _entry[PD_ENTRIES]; // the Phy_Addr in each entry passed through phy2pde()
+    };
 
     // Chunk (for Segment)
     class Chunk
@@ -270,6 +324,7 @@ template<unsigned int ENTRIES>
         void activate() const { ARMv8_MMU::pd(_pd); }
 
         Log_Addr attach(const Chunk & chunk, unsigned int from = directory(APP_LOW)) {
+            flush_tlb();
             for(unsigned int i = from; i < directory(SYS); i++)
                 if(attach(i, chunk.pt(), chunk.pts(), chunk.flags()))
                     return i << DIRECTORY_SHIFT;
@@ -277,6 +332,7 @@ template<unsigned int ENTRIES>
         }
 
         Log_Addr attach(const Chunk & chunk, Log_Addr addr) {
+            flush_tlb();
             unsigned int from = directory(addr);
             if(attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
                 return from << DIRECTORY_SHIFT;
@@ -284,6 +340,7 @@ template<unsigned int ENTRIES>
         }
 
         void detach(const Chunk & chunk) {
+            flush_tlb();
             for(unsigned int i = 0; i < PD_ENTRIES; i++) {
                 if(indexes(pte2phy((*_pd)[i])) == indexes(chunk.pt())) {
                     detach(i, chunk.pt(), chunk.pts());
@@ -294,6 +351,7 @@ template<unsigned int ENTRIES>
         }
 
         void detach(const Chunk & chunk, Log_Addr addr) {
+            flush_tlb();
             unsigned int from = directory(addr);
             if(indexes(pte2phy((*_pd)[from])) != indexes(chunk.pt())) {
                 db<MMU>(WRN) << "MMU::Directory::detach(pt=" << chunk.pt() << ",addr=" << addr << ") failed!" << endl;
@@ -311,6 +369,7 @@ template<unsigned int ENTRIES>
 
     private:
         bool attach(unsigned int from, const Page_Table * pt, unsigned int n, Page_Flags flags) {
+            flush_tlb();
             for(unsigned int i = from; i < from + n; i++)
                 if(_pd->log()[i])
                     return false;
@@ -320,7 +379,9 @@ template<unsigned int ENTRIES>
         }
 
         void detach(unsigned int from, const Page_Table * pt, unsigned int n) {
+            flush_tlb();
             for(unsigned int i = from; i < from + n; i++) {
+                flush_tlb();
                 _pd->log()[i] = 0;
                 // flush_tlb(i << DIRECTORY_SHIFT);
             }
@@ -471,10 +532,10 @@ public:
     }
 
     static Phy_Addr pd() { return CPU::pd(); }
-    static void pd(Phy_Addr pd) { CPU::pd(pd); /*CPU::flush_tlb();*/ CPU::isb(); CPU::dsb(); }
+    static void pd(Phy_Addr pd) { CPU::pd(pd); CPU::flush_tlb(); CPU::isb(); CPU::dsb(); }
 
-    static void flush_tlb() { /*CPU::flush_tlb();*/ }
-    static void flush_tlb(Log_Addr addr) { /*CPU::flush_tlb(directory_bits(addr));*/ } // only bits from 31 to 12, all ASIDs
+    static void flush_tlb() { CPU::flush_tlb(); }
+    static void flush_tlb(Log_Addr addr) { CPU::flush_tlb(directory_bits(addr)); } // only bits from 31 to 12, all ASIDs
 
     static void init();
 
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 4ebfbfe..a0fdb03 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -50,6 +50,7 @@ public:
             IO   = 1 << 8, // Memory Mapped I/O (0=memory, 1=I/O)
             SYS  = (PRE | RD | RW | EX),
             APP  = (PRE | RD | RW | EX | USR),
+            SHR  = (PRE | RD | RW | EX | USR),
             APPC = (PRE | RD | EX | USR),
             APPD = (PRE | RD | RW | USR)
         };
diff --git a/include/memory.h b/include/memory.h
index 63899b1..78b7b3e 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -12,8 +12,9 @@ class Address_Space: private MMU::Directory
     friend class Init_System;   // for Address_Space(pd)
     friend class Thread;        // for Address_Space(pd)
     friend class Scratchpad;    // for Address_Space(pd)
+    friend class Task;
 
-private:
+public:
     using MMU::Directory::activate;
 
 public:
diff --git a/include/process.h b/include/process.h
index e7beb71..a193ddd 100644
--- a/include/process.h
+++ b/include/process.h
@@ -26,6 +26,7 @@ class Thread
 protected:
     static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
+    static const bool multitask = Traits<System>::multitask;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
     static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
@@ -58,12 +59,13 @@ public:
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), criterion(c), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE, Task * t = 0)
+        : state(s), criterion(c), stack_size(ss), task(t) {}
 
         State state;
         Criterion criterion;
         unsigned int stack_size;
+        Task * task;
     };
 
 
@@ -86,6 +88,7 @@ public:
     void resume();
 
     static Thread * volatile self() { return running(); }
+    Task * task() const { return _task; }
     static void yield();
     static void exit(int status = 0);
 
@@ -118,6 +121,8 @@ private:
 
 protected:
     char * _stack;
+    Task * _task;
+    Segment  * _ustack;
     Context * volatile _context;
     volatile State _state;
     Queue * _waiting;
@@ -129,24 +134,92 @@ protected:
     static Scheduler<Thread> _scheduler;
 };
 
-
-template<typename ... Tn>
-inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
-: _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+ // Task (only used in multitasking configurations)
+class Task
 {
-    constructor_prologue(STACK_SIZE);
-    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
-    constructor_epilogue(entry, STACK_SIZE);
-}
+    friend class Thread;
 
-template<typename ... Tn>
-inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
-{
-    constructor_prologue(conf.stack_size);
-    _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
-    constructor_epilogue(entry, conf.stack_size);
-}
+private:
+    typedef CPU::Log_Addr Log_Addr;
+    typedef CPU::Phy_Addr Phy_Addr;
+    typedef CPU::Context Context;
+
+protected:
+    template<typename ... Tn>
+    Task(Address_Space * as, Segment * cs, Segment * ds, int (* entry)(Tn ...), const Log_Addr & code, const Log_Addr & data, Tn ... an)
+    : _as(as), _cs(cs), _ds(ds), _entry(entry), _code(code), _data(data) {
+        db<Task, Init>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+        lock();
+        _id = _task_count++;
+        unlock();
+        _current = this;
+        activate();
+        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN, Traits<Application>::STACK_SIZE, this), entry, an ...);
+    }
+
+public:
+    template<typename ... Tn>
+    Task(Segment * cs, Segment * ds, int (* entry)(Tn ...), const Log_Addr & code, const Log_Addr & data, Tn ... an)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs, code)), _data(_as->attach(_ds, data)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+        lock();
+        _id = _task_count++;
+        unlock();
+        _main = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::MAIN, Traits<Application>::STACK_SIZE, this), entry, an ...);
+    }
+    ~Task();
+
+    Address_Space * address_space() const { return _as; }
+
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
+
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
+
+    Thread * main() const { return _main; }
+
+    static Task * volatile self() { return current(); }
+    Log_Addr entry() { return _entry; }
+
+    unsigned int id() {return _id;}
+
+    void activate_context() {
+        activate();
+        MMU::flush_tlb();
+        lock();
+        _current = this;
+        unlock();
+    }
+
+private:
+    void activate() const { _as->activate(); }
+
+    void insert(Thread * t) { _threads.insert(new (SYSTEM) Thread::Queue::Element(t)); }
+    void remove(Thread * t) { Thread::Queue::Element * el = _threads.remove(t); if(el) delete el; }
+
+    static Task * volatile current() { return _current; }
+    static void current(Task * t) { _current = t; }
+
+    static void lock() { CPU::int_disable(); }
+    static void unlock() { CPU::int_enable(); }
+
+private:
+    unsigned int _id;
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _entry;
+    Log_Addr _code;
+    Log_Addr _data;
+    Thread * _main;
+    Thread::Queue _threads;
+
+    static Task * volatile _current;
+
+protected:
+    static volatile unsigned int _task_count;
+};
 
 
 // A Java-like Active Object
@@ -178,6 +251,38 @@ private:
     Thread * _handler;
 };
 
+template<typename ... Tn>
+inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
+:_task(Task::self()), _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
+{
+    constructor_prologue(STACK_SIZE);
+    _context = CPU::init_stack(0, _stack + STACK_SIZE, &__exit, entry, an ...);
+    constructor_epilogue(entry, STACK_SIZE);
+
+    _task->insert(this);
+}
+
+template<typename ... Tn>
+inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+:_task(conf.task ? conf.task : Task::self()), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+{
+    constructor_prologue(conf.stack_size);
+
+    if (conf.criterion == Thread::IDLE) {
+        _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
+    } else {
+        _ustack = new (SYSTEM) Segment(Traits<Machine>::STACK_SIZE, Segment::Flags::APP);
+        CPU::Log_Addr usp = _task->address_space()->attach(_ustack);
+        db<Thread>(TRC) << "UStack attached at vaddr=" << usp << endl;
+        _context = CPU::init_user_stack(usp + Traits<Machine>::STACK_SIZE, _stack + Traits<Machine>::STACK_SIZE, &__exit, entry, an ...);
+        db<Thread>(TRC) << "Context attached at vaddr=" << hex << _context << endl;
+    }
+    constructor_epilogue(entry, conf.stack_size);
+    if (conf.criterion != Thread::IDLE) {
+        _task->insert(this);
+    }
+}
+
 __END_SYS
 
 #endif
diff --git a/include/real-time.h b/include/real-time.h
new file mode 100644
index 0000000..aef254e
--- /dev/null
+++ b/include/real-time.h
@@ -0,0 +1,116 @@
+// EPOS Real-time Declarations
+
+#ifndef __real_time_h
+#define __real_time_h
+
+#include <utility/handler.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+#include <time.h>
+#include <process.h>
+#include <synchronizer.h>
+
+__BEGIN_SYS
+
+// Aperiodic Thread
+typedef Thread Aperiodic_Thread;
+
+// Periodic threads are achieved by programming an alarm handler to invoke
+// p() on a control semaphore after each job (i.e. task activation). Base
+// threads are created in BEGINNING state, so the scheduler won't dispatch
+// them before the associate alarm and semaphore are created. The first job
+// is dispatched by resume() (thus the _state = SUSPENDED statement)
+
+// Periodic Thread
+class Periodic_Thread: public Thread
+{
+public:
+    enum {
+        SAME    = Real_Time_Scheduler_Common::SAME,
+        NOW     = Real_Time_Scheduler_Common::NOW,
+        UNKNOWN = Real_Time_Scheduler_Common::UNKNOWN,
+        ANY     = Real_Time_Scheduler_Common::ANY
+    };
+
+protected:
+    // Alarm Handler for periodic threads under static scheduling policies
+    class Static_Handler: public Semaphore_Handler
+    {
+    public:
+        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
+        ~Static_Handler() {}
+    };
+
+    // Alarm Handler for periodic threads under dynamic scheduling policies
+    class Dynamic_Handler: public Semaphore_Handler
+    {
+    public:
+        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
+        ~Dynamic_Handler() {}
+
+        void operator()() {
+            _thread->criterion().update();
+
+            Semaphore_Handler::operator()();
+        }
+
+    private:
+        Periodic_Thread * _thread;
+    };
+
+    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
+
+public:
+    struct Configuration: public Thread::Configuration {
+        Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
+
+        Microsecond period;
+        Microsecond deadline;
+        Microsecond capacity;
+        Microsecond activation;
+        unsigned int times;
+    };
+
+public:
+    template<typename ... Tn>
+    Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+
+    template<typename ... Tn>
+    Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+        if((conf.state == READY) || (conf.state == RUNNING)) {
+            _state = SUSPENDED;
+            resume();
+        } else
+            _state = conf.state;
+    }
+
+    const Microsecond & period() const { return _alarm.period(); }
+    void period(const Microsecond & p) { _alarm.period(p); }
+
+    static volatile bool wait_next() {
+        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+
+        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+
+        if(t->_alarm.times())
+            t->_semaphore.p();
+
+        return t->_alarm.times();
+    }
+
+protected:
+    Semaphore _semaphore;
+    Handler _handler;
+    Alarm _alarm;
+};
+
+typedef Periodic_Thread::Configuration RTConf;
+
+__END_SYS
+
+#endif
\ No newline at end of file
diff --git a/include/scheduler.h b/include/scheduler.h
index 99bfd36..7e50828 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -145,6 +145,39 @@ public:
     FCFS(int p = NORMAL, Tn & ... an);
 };
 
+
+class Real_Time_Scheduler: public Priority
+{
+protected:
+    Real_Time_Scheduler(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {}
+    Real_Time_Scheduler(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
+    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
+
+public:
+    const Microsecond period() { return _period; }
+    void period(const Microsecond & p) { _period = p; }
+
+public:
+    Microsecond _deadline;
+    Microsecond _period;
+    Microsecond _capacity;
+};
+
+// Deadline Monotonic
+class DM: public Real_Time_Scheduler
+{
+
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    DM(int p = APERIODIC): Real_Time_Scheduler(p) {}
+    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+    : Real_Time_Scheduler(d, d, p, c) {}
+};
+
 __END_SYS
 
 #endif
diff --git a/include/syscall/agent.h b/include/syscall/agent.h
new file mode 100644
index 0000000..3c316a7
--- /dev/null
+++ b/include/syscall/agent.h
@@ -0,0 +1,483 @@
+// EPOS Thread Component Declarations
+
+#ifndef __agent_h
+#define __agent_h
+
+#include <architecture.h>
+#include <machine.h>
+#include <syscall/message.h>
+
+#include <time.h>
+#include <memory.h>
+#include <process.h>
+#include <synchronizer.h>
+#include <time.h>
+
+__BEGIN_SYS
+
+class Agent: public Message
+{
+public:
+    static void _exec(){
+        Agent * agt;
+        ASM("mov %0, x0  " : "=r"(agt) :);
+        agt->exec();
+    }
+    void exec() {
+        switch(entity()) {
+            case Message::ENTITY::DISPLAY:
+                handle_display();
+                break;
+            case Message::ENTITY::THREAD:
+                handle_thread();
+                break;
+            case Message::ENTITY::TASK:
+                handle_task();
+                break; 
+            case Message::ENTITY::ADDRESS_SPACE:
+                handle_address_space();
+                break;  
+            case Message::ENTITY::SEGMENT:
+                handle_segment();
+                break;
+            case Message::ENTITY::MUTEX:
+                handle_mutex();
+                break;
+            case Message::ENTITY::SEMAPHORE:
+                handle_semaphore();
+                break;
+            case Message::ENTITY::CONDITION:
+                handle_condition();
+                break;
+            case Message::ENTITY::CLOCK:
+                handle_clock();
+                break;
+            case Message::ENTITY::ALARM:
+                handle_alarm();
+                break;
+            case Message::ENTITY::DELAY:
+                handle_delay();
+                break;
+            case Message::ENTITY::CHRONOMETER:
+                handle_chronometer();
+                break;
+            default:
+                break;
+        }
+    }
+
+private:
+    void handle_display() {
+        switch(method()) {
+            case Message::PRINT: {
+                const char * s;
+                get_params(s);
+                Display::puts(s);
+            } break;
+            default:
+                break;
+        }
+    }
+
+    void handle_thread() {
+        switch(method()) {
+            case Message::THREAD_CREATE: {
+                int (* entry)();
+                get_params(entry);
+                Thread * t = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::NORMAL), entry);
+                result(reinterpret_cast<long>(t));
+            }   break;
+            case Message::THREAD_CREATE_CONFIG: {
+                int (* entry)();
+                get_params(entry);
+                new (SYSTEM) Thread(entry);
+            }   break;
+            /*
+            case Message::THREAD_PRIORITY1: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                Criterion & p;
+                get_params(p);
+                t->priority(p);
+            } */
+            case Message::THREAD_TASK: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                Task * task = t->task();
+                result(reinterpret_cast<long>(task));
+            }   break;
+            case Message::THREAD_JOIN: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                int r = t->join();
+                result(r);
+            }   break;
+            case Message::THREAD_PASS: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                t->pass();
+            }   break;
+            case Message::THREAD_SUSPEND: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                t->suspend();
+            }   break;
+            case Message::THREAD_RESUME: {
+                Thread * t = reinterpret_cast<Thread *>(id());
+                t->resume();
+            }   break;
+            case Message::THREAD_SELF: {
+                Thread * t = Thread::self();
+                result(reinterpret_cast<long>(t));
+                break;
+            }
+            case Message::THREAD_YIELD: {
+                Thread::yield();
+            }   break;
+            case Message::THREAD_EXIT: {
+                int status;
+                get_params(status);
+                Thread::exit(status);
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+
+    void handle_task(){
+        switch(method()) {
+            case Message::TASK_CREATE: {
+                Segment * cs; 
+                Segment * ds; 
+                int (* entry)();
+                Address_Space::Log_Addr code; 
+                Address_Space::Log_Addr data; 
+                get_params(cs, ds, entry, code, data);
+                Task * t = new (SYSTEM) Task(cs, ds, entry, code, data);
+                result(reinterpret_cast<long>(t));
+            }   break;
+            case Message::TASK_ADDRESS_SPACE: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Address_Space * a = t->address_space();
+                result(reinterpret_cast<long>(a));
+            }   break;
+            case Message::TASK_CODE_SEGMENT: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Segment * s = t->code_segment();
+                result(reinterpret_cast<long>(s));
+            }   break;
+            case Message::TASK_DATA_SEGMENT: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Segment * s = t->data_segment();
+                result(reinterpret_cast<long>(s));
+            }   break;
+            case Message::TASK_CODE: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Address_Space::Log_Addr l = t->code();
+                result(l);
+            }   break;
+            case Message::TASK_DATA: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Address_Space::Log_Addr l = t->data();
+                result(l);
+            }   break;
+            case Message::TASK_MAIN: {
+                Task * t = reinterpret_cast<Task *>(id());
+                Thread * m = t->main();
+                result(reinterpret_cast<long>(m));
+            }   break;
+            case Message::TASK_ID: {
+                Task * t = reinterpret_cast<Task *>(id());
+                unsigned int r = t->id();
+                result(r);
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+
+    void handle_address_space(){
+        switch(method()) {
+            case Message::ADDRESS_SPACE_CREATE: {
+                Address_Space * a = new (SYSTEM) Address_Space();
+                result(reinterpret_cast<long>(a));
+            }   break;
+            case Message::ADDRESS_SPACE_CREATE_PD: {
+                MMU::Page_Directory * pd;
+                get_params(pd);
+                Address_Space * a = new (SYSTEM) Address_Space(pd);
+                result(reinterpret_cast<long>(a));
+            }   break;
+            case Message::ADDRESS_SPACE_ATTACH1: {
+                Segment * seg;
+                Address_Space * a = reinterpret_cast<Address_Space *>(id());
+                get_params(seg);
+                result(a->attach(seg));
+            }   break;
+            case Message::ADDRESS_SPACE_ATTACH2: {
+                Segment * seg;
+                Address_Space::Log_Addr addr;
+                Address_Space * a = reinterpret_cast<Address_Space *>(id());
+                get_params(seg, addr);
+                result(a->attach(seg, addr));
+            }   break;
+            case Message::ADDRESS_SPACE_DETACH1 : {
+                Segment * seg;
+                Address_Space * a = reinterpret_cast<Address_Space *>(id());
+                get_params(seg);
+                a->detach(seg);
+            }   break;
+            case Message::ADDRESS_SPACE_DETACH2 : {
+                Segment * seg;
+                Address_Space::Log_Addr addr;
+                Address_Space * a = reinterpret_cast<Address_Space *>(id());
+                get_params(seg, addr);
+                a->detach(seg, addr);
+            }   break;
+            case Message::ADDRESS_SPACE_PHYSICAL : {
+                Address_Space::Log_Addr address;
+                Address_Space * a = reinterpret_cast<Address_Space *>(id());
+                get_params(address);
+                result(a->physical(address));
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_segment(){
+        switch(method()) {
+            case Message::SEGMENT_CREATE: {
+                unsigned int bytes;
+                Segment::Flags flags;
+                get_params(bytes, flags);
+                Segment * s = new (SYSTEM) Segment(bytes, flags);
+                result(reinterpret_cast<long>(s));
+            }   break;
+            case Message::SEGMENT_CREATE_PHY: {
+                Segment::Phy_Addr phy_addr;
+                unsigned int bytes;
+                Segment::Flags flags;
+                get_params(phy_addr, bytes, flags);
+                Segment * s = new (SYSTEM) Segment(phy_addr, bytes, flags);
+                result(reinterpret_cast<long>(s));
+            } break;
+            case Message::SEGMENT_SIZE: {
+                Segment * s = reinterpret_cast<Segment *>(id());
+                int r = s->size();
+                result(r);
+            } break;
+            case Message::SEGMENT_PHY_ADDRESS: {
+                Segment * s = reinterpret_cast<Segment *>(id());
+                int r = s->phy_address();
+                result(r);
+            } break;
+            case Message::SEGMENT_RESIZE: {
+                Segment * s = reinterpret_cast<Segment *>(id());
+                int amount;
+                get_params(amount);
+                int r = s->resize(amount);
+                result(r);
+            } break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        } 
+    }
+    void handle_mutex() {
+        switch(method()) {
+            case Message::MUTEX_CREATE: {
+                Mutex * m = new (SYSTEM) Mutex();
+                db<Agent>(TRC) << "AGENT CREATE MUTEX" << endl;
+                result(reinterpret_cast<long>(m));
+            }   break;
+            case Message::MUTEX_LOCK: {
+                Mutex * m = reinterpret_cast<Mutex *>(id());
+                m->lock();
+                db<Agent>(TRC) << "AGENT MUTEX LOCK" << endl;
+            }   break;
+            case Message::MUTEX_UNLOCK: {
+                Mutex * m = reinterpret_cast<Mutex *>(id());
+                m->unlock();
+                db<Agent>(TRC) << "AGENT MUTEX UNLOCK" << endl;
+            }   break;
+            case Message::MUTEX_HANDLER: {
+                Mutex * m = reinterpret_cast<Mutex *>(id());
+                Mutex_Handler * h = new (SYSTEM) Mutex_Handler(m);
+                db<Agent>(TRC) << "AGENT NEW MUTEX_HANDLER" << endl;
+                result(reinterpret_cast<long>(h));
+            }   break;
+            case Message::MUTEX_OPERATOR: {
+                Mutex_Handler * h = reinterpret_cast<Mutex_Handler *>(id());
+                (* h)();
+                db<Agent>(TRC) << "AGENT MUTEX_HANDLER ()" << endl;
+            }   break;
+            default:
+                db<Agent>(TRC) << "MUTEX FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_semaphore(){
+        switch(method()) {
+            case Message::SEMAPHORE_CREATE: {
+                int v;
+                get_params(v);
+                Semaphore * s = new (SYSTEM) Semaphore(v);
+                result(reinterpret_cast<long>(s));
+            }   break;
+            case Message::SEMAPHORE_P: {
+                Semaphore * s = reinterpret_cast<Semaphore *>(id());
+                s->p();
+            }   break;
+            case Message::SEMAPHORE_V: {
+                Semaphore * s = reinterpret_cast<Semaphore *>(id());
+                s->v();
+            }   break;
+            case Message::SEMAPHORE_HANDLER: {
+                Semaphore * s;
+                get_params(s);
+                Semaphore_Handler * sh = new (SYSTEM) Semaphore_Handler(s);
+                result(reinterpret_cast<long>(sh));
+            }   break;
+            case Message::SEMAPHORE_OPERATOR : {
+                Semaphore_Handler * sh;
+                get_params(sh);
+                (*sh)();
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_condition(){
+        switch(method()) {
+            case Message::CONDITION_CREATE: {
+                Condition * c = new (SYSTEM) Condition();
+                result(reinterpret_cast<long>(c));
+            }   break;
+            case Message::CONDITION_WAIT: {
+                Condition * c = reinterpret_cast<Condition *>(id());
+                c->wait();
+                // db<Agent>(TRC) << "AHH CREATE THREAD" << endl;
+            }   break;
+            case Message::CONDITION_SIGNAL: {
+                Condition * c = reinterpret_cast<Condition *>(id());
+                c->signal();
+                // db<Agent>(TRC) << "AHH CREATE THREAD" << endl;
+            }   break;
+            case Message::CONDITION_BROADCAST: {
+                Condition * c = reinterpret_cast<Condition *>(id());
+                c->broadcast();
+                // db<Agent>(TRC) << "AHH EXIT THREAD" << endl;
+            }   break;
+            case Message::CONDITION_HANDLER: {
+                Condition * c;
+                get_params(c);
+                Condition_Handler * ch = new (SYSTEM) Condition_Handler(c);
+                result(reinterpret_cast<long>(ch));
+            }   break;
+            case Message::CONDITION_OPERATOR : {
+                Condition_Handler * ch;
+                get_params(ch);
+                (*ch)();
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_clock(){}
+    void handle_alarm(){
+        switch(method()) {
+            case Message::ALARM_CREATE: {
+                Microsecond time;
+                Handler * handler;
+                unsigned int times;
+                get_params(time, handler, times);
+                Alarm * a = new (SYSTEM) Alarm(time, handler, times);
+                result(reinterpret_cast<long>(a));
+            }   break;
+            case Message::ALARM_PERIOD: {
+                Microsecond p;
+                Alarm * a = reinterpret_cast<Alarm *>(id());
+                p = a->period();
+                result(p);
+            }   break;
+            case Message::ALARM_PERIOD1: {
+                Microsecond p;
+                Alarm * a = reinterpret_cast<Alarm *>(id());
+                get_params(p);
+                a->period(p);
+            }   break;
+            case Message::ALARM_RESET: {
+                Alarm * a = reinterpret_cast<Alarm *>(id());
+                a->reset();
+            }   break;
+            case Message::ALARM_FREQUENCY : {
+                result(Alarm::frequency());
+            }   break;
+            case Message::ALARM_DELAY : {
+                Microsecond time;
+                get_params(time);
+                Alarm * a = reinterpret_cast<Alarm *>(id());
+                a->delay(time);
+            }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_delay(){
+        switch(method()) {
+            case Message::DELAY_CREATE: {
+                Microsecond time;
+                get_params(time);
+                Delay * d = new (SYSTEM) Delay(reinterpret_cast<const Microsecond &>(time));
+                result(reinterpret_cast<long>(d));
+            }   break;
+          default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+    void handle_chronometer(){
+        switch(method()) {
+            case Message::CHRONOMETER_CREATE: {
+                Chronometer * c = new (SYSTEM) Chronometer();
+                result(reinterpret_cast<long>(c));
+            }   break;
+            case Message::CHRONOMETER_FREQUENCY: {
+                Chronometer * c = reinterpret_cast<Chronometer *>(id());
+                Hertz p = c->frequency();
+                result(p);
+                // db<Agent>(TRC) << "AHH CREATE THREAD" << endl;
+            }   break;
+            case Message::CHRONOMETER_RESET: {
+                Chronometer * c = reinterpret_cast<Chronometer *>(id());
+                c->reset();
+                // db<Agent>(TRC) << "AHH EXIT THREAD" << endl;
+            }   break;
+            case Message::CHRONOMETER_START: {
+              Chronometer * c = reinterpret_cast<Chronometer *>(id());
+              c->start();
+          }   break;
+            case Message::CHRONOMETER_LAP : {
+              Chronometer * c = reinterpret_cast<Chronometer *>(id());
+              c->lap();
+          }   break;
+            case Message::CHRONOMETER_STOP : {
+              Chronometer * c = reinterpret_cast<Chronometer *>(id());
+              c->stop();
+          }   break;
+            case Message::CHRONOMETER_READ : {
+              Chronometer * c = reinterpret_cast<Chronometer *>(id());
+              result(c->read());
+          }   break;
+            default:
+                db<Agent>(TRC) << "FAILED :(" << endl;
+                break;
+        }
+    }
+};
+
+__END_SYS
+
+#endif
+  
\ No newline at end of file
diff --git a/include/syscall/message.h b/include/syscall/message.h
new file mode 100644
index 0000000..b2d2edc
--- /dev/null
+++ b/include/syscall/message.h
@@ -0,0 +1,161 @@
+// EPOS Thread Component Declarations
+
+#ifndef __message_h
+#define __message_h
+
+#include <architecture.h>
+
+extern "C" { void _syscall(void *); }
+
+__BEGIN_SYS
+
+class Message
+{
+public:
+    enum {
+        PRINT,
+        DELETE,
+
+        THREAD_CREATE,
+        THREAD_CREATE_CONFIG,
+        //THREAD_PRIORITY,
+        THREAD_PRIORITY1,
+        THREAD_TASK,
+        THREAD_JOIN,
+        THREAD_PASS,
+        THREAD_SUSPEND,
+        THREAD_RESUME,
+        THREAD_SELF,
+        THREAD_YIELD,
+        THREAD_EXIT,
+        THREAD_WAIT_NEXT,
+
+        TASK_CREATE,
+        TASK_ADDRESS_SPACE,
+        TASK_CODE_SEGMENT,
+        TASK_DATA_SEGMENT,
+        TASK_CODE,
+        TASK_DATA,
+        TASK_MAIN,
+        TASK_ENTRY,
+        TASK_ID,
+
+        ADDRESS_SPACE_CREATE, 
+        ADDRESS_SPACE_CREATE_PD, 
+        ADDRESS_SPACE_ATTACH1,
+        ADDRESS_SPACE_ATTACH2,
+        ADDRESS_SPACE_DETACH1,
+        ADDRESS_SPACE_DETACH2,
+        ADDRESS_SPACE_PHYSICAL,
+
+        SEGMENT_CREATE,
+        SEGMENT_CREATE_PHY,
+        SEGMENT_SIZE,
+        SEGMENT_PHY_ADDRESS,
+        SEGMENT_RESIZE,
+
+        MUTEX_CREATE,
+        MUTEX_LOCK,
+        MUTEX_UNLOCK,
+        MUTEX_HANDLER,
+        MUTEX_OPERATOR,
+
+        SEMAPHORE_CREATE,
+        SEMAPHORE_P,
+        SEMAPHORE_V,
+        SEMAPHORE_HANDLER,
+        SEMAPHORE_OPERATOR,
+
+        CONDITION_CREATE,
+        CONDITION_WAIT,
+        CONDITION_SIGNAL,
+        CONDITION_BROADCAST,
+        CONDITION_HANDLER,
+        CONDITION_OPERATOR,
+
+        CLOCK_CREATE,
+        CLOCK_RESOLUTION,
+        CLOCK_NOW,
+        CLOCK_DATE,
+        CLOCK_DATE1,
+
+        ALARM_CREATE,
+        ALARM_PERIOD,
+        ALARM_PERIOD1,
+        ALARM_RESET,
+        ALARM_FREQUENCY,
+        ALARM_DELAY,
+        ALARM_TIMES,
+        ALARM_TIMER_PERIOD,
+        ALARM_TICKS,
+        ALARM_LOCK,
+        ALARM_UNLOCK,
+        ALARM_HANDLER,
+        ALARM_INIT,
+
+        DELAY_CREATE,
+
+        CHRONOMETER_CREATE,
+        CHRONOMETER_FREQUENCY,
+        CHRONOMETER_RESET,
+        CHRONOMETER_START,
+        CHRONOMETER_LAP,
+        CHRONOMETER_STOP,
+        CHRONOMETER_READ,
+    };
+    enum ENTITY {
+        DISPLAY,
+        THREAD,
+        TASK,
+        ADDRESS_SPACE,
+        SEGMENT,
+        MUTEX,
+        SEMAPHORE,
+        CONDITION,
+        CLOCK,
+        ALARM,
+        DELAY,
+        CHRONOMETER,
+    };
+public:
+    template<typename ... Tn>
+    Message(int entity, int method, Tn ... an): _entity(entity), _method(method) {set_params(an ...);}
+
+    template<typename ... Tn>
+    Message(int id, int entity, int method, Tn ... an): _id(id), _entity(entity), _method(method) {set_params(an ...);}
+
+    template<typename ... Tn>
+    void get_params(Tn && ... an) {
+        // Force a compilation error in case out is called with too many arguments
+        typename IF<(SIZEOF<Tn ...>::Result <= 256), int, void>::Result index = 0;
+        DESERIALIZE(_params, index, an ...);
+    }
+    template<typename ... Tn>
+    void set_params(const Tn & ... an) {
+        // Force a compilation error in case out is called with too many arguments
+        typename IF<(SIZEOF<Tn ...>::Result <= 256), int, void>::Result index = 0;
+        SERIALIZE(_params, index, an ...);
+    }
+
+    void act() { _syscall(this); }
+
+    int id(){return _id;}
+    int entity(){return _entity;}
+    int method(){return _method;}
+    int result(){return _result;}
+    void result(long r){_result = r;}
+    char* params(){return _params;}
+
+private:
+    int _id;
+    int _entity;
+    int _method;
+    long _result;
+    char _params[256];
+
+};
+
+
+__END_SYS
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_address_space.h b/include/syscall/stub_address_space.h
new file mode 100644
index 0000000..5c9f26f
--- /dev/null
+++ b/include/syscall/stub_address_space.h
@@ -0,0 +1,72 @@
+// EPOS Component Declarations
+
+#ifndef __stub_address_space_h
+#define __stub_address_space_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <memory.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Address_Space
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+    // typedef Message::ENTITY::SEMAPHORE SEMAPHORE;
+
+
+public:
+    Stub_Address_Space(){}
+    void set_id(int _id) {id = _id;}
+
+    template<typename ... Tn>
+    Stub_Address_Space(Tn ... an){
+        Message * msg = new Message(Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+
+    template<typename ... Tn>
+    Stub_Address_Space(_SYS::MMU::Page_Directory * pd, Tn ... an){
+        Message * msg = new Message(Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_CREATE_PD, pd);
+        msg->act();
+        id = msg->result();
+    }
+
+    _SYS::Address_Space::Log_Addr attach(_SYS::Segment * seg) {
+        Message * msg = new Message(id, Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_ATTACH1, seg);
+        msg->act();
+        return msg->result();
+    }
+
+    _SYS::Address_Space::Log_Addr attach(_SYS::Segment * seg, _SYS::Address_Space::Log_Addr addr) {
+        Message * msg = new Message(id, Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_ATTACH2, seg, addr);
+        msg->act();
+        return msg->result();
+    }
+
+    void detach(_SYS::Segment * seg) {
+        Message * msg = new Message(id, Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_DETACH1, seg);
+        msg->act();
+    }
+
+    void detach(_SYS::Segment * seg, _SYS::Address_Space::Log_Addr addr) {
+        Message * msg = new Message(id, Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_DETACH2, seg, addr);
+        msg->act();
+    }
+
+    _SYS::Address_Space::Phy_Addr physical(_SYS::Address_Space::Log_Addr addr) {
+        Message * msg = new Message(id, Message::ENTITY::ADDRESS_SPACE, Message::ADDRESS_SPACE_PHYSICAL, addr);
+        msg->act();
+        return msg->result();
+    }
+
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_alarm.h b/include/syscall/stub_alarm.h
new file mode 100644
index 0000000..91e98dc
--- /dev/null
+++ b/include/syscall/stub_alarm.h
@@ -0,0 +1,64 @@
+// EPOS Component Declarations
+
+#ifndef __stub_alarm_h
+#define __stub_alarm_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <time.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Alarm
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+    // typedef Message::ENTITY::SEMAPHORE SEMAPHORE;
+
+
+public:
+    template<typename ... Tn>
+    Stub_Alarm(const Microsecond & time, Handler * handler, unsigned int times = 1, Tn ... an){
+        Message * msg = new Message(Message::ENTITY::ALARM, Message::ALARM_CREATE, time, handler, times);
+        msg->act();
+        id = msg->result();
+    }
+
+    /*
+    const Microsecond & period() {
+        Message *msg = new Message(id, Message::ENTITY::ALARM, Message::ALARM_PERIOD);
+        msg->act();
+        return msg->result();
+    }
+    */
+
+
+    void period(const Microsecond & p) {
+        Message *msg = new Message(id, Message::ENTITY::ALARM, Message::ALARM_PERIOD1, p);
+        msg->act();
+    }
+
+    void reset() {
+        Message *msg = new Message(id, Message::ENTITY::ALARM, Message::ALARM_RESET);
+        msg->act();
+    }
+
+    static Hertz frequency() {
+        Message *msg = new Message(Message::ENTITY::ALARM, Message::ALARM_FREQUENCY);
+        msg->act();
+        return (msg->result());
+    }
+
+    void delay(const Microsecond & time) {
+        Message *msg = new Message(id, Message::ENTITY::ALARM, Message::ALARM_DELAY, time);
+        msg->act();
+    }
+
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_chronometer.h b/include/syscall/stub_chronometer.h
new file mode 100644
index 0000000..72bc6a3
--- /dev/null
+++ b/include/syscall/stub_chronometer.h
@@ -0,0 +1,64 @@
+// EPOS Component Declarations
+
+#ifndef __stub_chronometer_h
+#define __stub_chronometer_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Chronometer
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+    // typedef Message::ENTITY::SEMAPHORE SEMAPHORE;
+
+public:
+    template<typename ... Tn>
+    Stub_Chronometer(Tn ... an){
+        Message * msg = new Message(Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+
+    Hertz frequency(){
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_FREQUENCY);
+        msg->act();
+        return msg->result();
+    }
+
+    void reset() {
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_RESET);
+        msg->act();
+    }
+
+    void start() {
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_START);
+        msg->act();
+    }
+
+    void lap() {
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_LAP);
+        msg->act();
+    }
+
+    void stop() {
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_STOP);
+        msg->act();
+    }
+
+    Microsecond read() {
+        Message * msg = new Message(id, Message::ENTITY::CHRONOMETER, Message::CHRONOMETER_READ);
+        msg->act();
+        return msg->result();
+    }
+
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_clock.h b/include/syscall/stub_clock.h
new file mode 100644
index 0000000..3f48e50
--- /dev/null
+++ b/include/syscall/stub_clock.h
@@ -0,0 +1,55 @@
+// EPOS Component Declarations
+
+#ifndef __stub_clock_h
+#define __stub_clock_h
+
+#include <architecture.h>
+#include <machine/rtc.h>
+#include <syscall/message.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Clock
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+    typedef Message::ENTITY::CLOCK CLOCK;
+    typedef RTC::Date Date;
+
+public:
+    Stub_Clock(){
+        Message * msg = new Message(CLOCK, Message::CLOCK_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+
+    Microsecond resolution() {
+        Message * msg = new Message(id, CLOCK, Message::CLOCK_RESOLUTION);
+        msg->act();
+        return msg->result();
+    }
+
+    Second now() {
+        Message * msg = new Message(id, CLOCK, Message::CLOCK_NOW);
+        msg->act();
+        return msg->result();
+    }
+
+    Date date() {
+        Message * msg = new Message(id, CLOCK, Message::CLOCK_DATE);
+        msg->act();
+        return msg->result();
+    }
+
+    void date() {
+        Message * msg = new Message(id, CLOCK, Message::CLOCK_DATE1);
+        msg->act();
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_condition.h b/include/syscall/stub_condition.h
new file mode 100644
index 0000000..5dfb37e
--- /dev/null
+++ b/include/syscall/stub_condition.h
@@ -0,0 +1,58 @@
+// EPOS Component Declarations
+
+#ifndef __stub_condition_h
+#define __stub_condition_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Condition
+{
+private:
+    int id;
+    int handler;
+    typedef _SYS::Message Message;
+
+public:
+    template<typename ... Tn>
+    Stub_Condition(Tn ... an){
+        Message * msg = new Message(Message::ENTITY::CONDITION, Message::CONDITION_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+
+    void wait(){
+        Message * msg = new Message(id, Message::ENTITY::CONDITION, Message::CONDITION_WAIT);
+        msg->act();
+    }
+
+    void signal(){
+        Message * msg = new Message(id, Message::ENTITY::CONDITION, Message::CONDITION_SIGNAL);
+        msg->act();
+    }
+
+    void broadcast(){
+        Message * msg = new Message(id, Message::ENTITY::CONDITION, Message::CONDITION_BROADCAST);
+        msg->act();
+    }
+
+    // handler
+    void condition_handler(){
+        Message * msg = new Message(id, Message::ENTITY::CONDITION, Message::CONDITION_HANDLER, id);
+        msg->act();
+        handler = msg->result();
+    }
+
+    void operator()(){
+        Message * msg = new Message(id, Message::ENTITY::CONDITION, Message::CONDITION_OPERATOR, handler);
+        msg->act();
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_delay.h b/include/syscall/stub_delay.h
new file mode 100644
index 0000000..8ed6309
--- /dev/null
+++ b/include/syscall/stub_delay.h
@@ -0,0 +1,32 @@
+// EPOS Component Declarations
+
+#ifndef __stub_delay_h
+#define __stub_delay_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <time.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Delay
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+    // typedef Message::ENTITY::SEMAPHORE SEMAPHORE;
+
+
+public:
+    Stub_Delay(const Microsecond & time){
+        Message * msg = new Message(Message::ENTITY::DELAY, Message::DELAY_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_mutex.h b/include/syscall/stub_mutex.h
new file mode 100644
index 0000000..4ee846c
--- /dev/null
+++ b/include/syscall/stub_mutex.h
@@ -0,0 +1,60 @@
+// EPOS Component Declarations
+
+#ifndef __stub_mutex_h
+#define __stub_mutex_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Mutex
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+
+public:
+    Stub_Mutex(){
+        Message * msg = new Message(Message::ENTITY::MUTEX, Message::MUTEX_CREATE);
+        msg->act();
+        id = msg->result();
+    }
+
+    void lock() {
+        Message * msg = new Message(id, Message::ENTITY::MUTEX, Message::MUTEX_LOCK);
+        msg->act();
+    }
+
+    void unlock() {
+        Message * msg = new Message(id, Message::ENTITY::MUTEX, Message::MUTEX_UNLOCK);
+        msg->act();
+    }
+};
+
+class Stub_Mutex_Handler {
+private:
+    int id;
+    typedef _SYS::Message Message;
+
+public:
+    // handler it self
+    Stub_Mutex_Handler(){
+        Message * msg = new Message(Message::ENTITY::MUTEX, Message::MUTEX_HANDLER);
+        msg->act();
+        id = msg->result();
+    }
+
+    /*
+    void operator()() {
+        Message * msg = new Message(handler, Message::ENTITY::MUTEX, Message::MUTEX_OPERATOR);
+        msg->act();
+    }
+    */
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_segment.h b/include/syscall/stub_segment.h
new file mode 100644
index 0000000..80cd747
--- /dev/null
+++ b/include/syscall/stub_segment.h
@@ -0,0 +1,61 @@
+// EPOS Component Declarations
+
+#ifndef __stub_segment_h
+#define __stub_segment_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <memory.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Segment
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+
+public:
+    Stub_Segment(){}
+    void set_id(int _id) {id = _id;}
+
+    Stub_Segment(unsigned int bytes, _SYS::MMU::Flags flags = _SYS::MMU::Flags::APP){
+        Message * msg = new Message(Message::ENTITY::SEGMENT, Message::SEGMENT_CREATE, bytes, flags);
+        msg->act();
+        id = msg->result();
+    }
+
+    Stub_Segment(_SYS::Segment::Phy_Addr phy_addr, unsigned int bytes, _SYS::MMU::Flags flags = _SYS::MMU::Flags::APP){
+        Message * msg = new Message(Message::ENTITY::SEGMENT, Message::SEGMENT_CREATE_PHY, phy_addr, bytes, flags);
+        msg->act();
+        id = msg->result();
+    }
+
+    unsigned int size () {
+        Message * msg = new Message(id, Message::ENTITY::SEGMENT, Message::SEGMENT_SIZE);
+        msg->act();
+        int r = msg->result();
+        return reinterpret_cast<int>(r);
+    }
+
+    _SYS::Segment::Phy_Addr phy_address() {
+        Message * msg = new Message(id, Message::ENTITY::SEGMENT, Message::SEGMENT_PHY_ADDRESS);
+        msg->act();
+        int r = msg->result();
+        //return reinterpret_cast<Segment::Phy_Addr>(r);
+        return r;
+    }
+
+    int resize (int amount) {
+        Message * msg = new Message(id, Message::ENTITY::SEGMENT, Message::SEGMENT_RESIZE, amount);
+        msg->act();
+        int r = msg->result();
+        return r;
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_semaphore.h b/include/syscall/stub_semaphore.h
new file mode 100644
index 0000000..064d78d
--- /dev/null
+++ b/include/syscall/stub_semaphore.h
@@ -0,0 +1,53 @@
+// EPOS Component Declarations
+
+#ifndef __stub_semaphore_h
+#define __stub_semaphore_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Semaphore
+{
+private:
+    int id;
+    int handler;
+    typedef _SYS::Message Message;
+
+public:
+    template<typename ... Tn>
+    Stub_Semaphore(int v, Tn ... an){
+        Message * msg = new Message(Message::ENTITY::SEMAPHORE, Message::SEMAPHORE_CREATE, v);
+        msg->act();
+        id = msg->result();
+    }
+
+    void p(){
+        Message * msg = new Message(id, Message::ENTITY::SEMAPHORE, Message::SEMAPHORE_P);
+        msg->act();
+    }
+
+    void v(){
+        Message * msg = new Message(id, Message::ENTITY::SEMAPHORE, Message::SEMAPHORE_V);
+        msg->act();
+    }
+
+    // handler
+    void semaphore_handler(){
+        Message * msg = new Message(id, Message::ENTITY::SEMAPHORE, Message::SEMAPHORE_HANDLER, id);
+        msg->act();
+        handler = msg->result();
+    }
+
+    void operator()(){
+        Message * msg = new Message(id, Message::ENTITY::SEMAPHORE, Message::SEMAPHORE_OPERATOR, handler);
+        msg->act();
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_task.h b/include/syscall/stub_task.h
new file mode 100644
index 0000000..a936a16
--- /dev/null
+++ b/include/syscall/stub_task.h
@@ -0,0 +1,96 @@
+// EPOS Component Declarations
+
+#ifndef __stub_task_h
+#define __stub_task_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <syscall/stub_address_space.h>
+#include <syscall/stub_segment.h>
+#include <memory.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Task
+{
+private:
+    int _id;
+    typedef _SYS::Message Message;
+
+public:
+    Stub_Task();
+
+    template<typename ... Tn>
+    Stub_Task(Stub_Segment * cs, Stub_Segment * ds, int (* entry)(Tn ...), const _SYS::Address_Space::Log_Addr & code, const _SYS::Address_Space::Log_Addr & data, Tn ... an){
+        Message * msg = new Message(Message::ENTITY::TASK, Message::TASK_CREATE, cs, ds, entry, code, data);
+        msg->act();
+        _id = msg->result();
+    }
+
+    Stub_Address_Space * address_space() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_ADDRESS_SPACE);
+        msg->act();
+        int a = msg->result();
+        Stub_Address_Space * as = new Stub_Address_Space();
+        as->set_id(a);
+        return reinterpret_cast<Stub_Address_Space *>(as);
+    }
+
+    Stub_Segment * code_segment() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_CODE_SEGMENT);
+        msg->act();
+        int s = msg->result();
+        Stub_Segment * sc = new Stub_Segment();
+        sc->set_id(s);
+        return reinterpret_cast<Stub_Segment *>(sc);
+    }
+
+    Stub_Segment * data_segment() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_DATA_SEGMENT);
+        msg->act();
+        int s = msg->result();
+        Stub_Segment * sd = new Stub_Segment();
+        sd->set_id(s);
+        return reinterpret_cast<Stub_Segment *>(sd);
+    }
+
+    _SYS::Address_Space::Log_Addr code() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_CODE);
+        msg->act();
+        int l = msg->result();
+        //return reinterpret_cast<Address_Space::Log_Addr>(l);
+        return l;
+    }
+
+    _SYS::Address_Space::Log_Addr data() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_DATA);
+        msg->act();
+        int l = msg->result();
+        //return reinterpret_cast<Address_Space::Log_Addr>(l);
+        return l;
+    }
+
+    /*Stub_Thread * main() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_MAIN);
+        msg->act();
+        int m = msg->result();
+        Stub_Thread * st = new Stub_Thread();
+        st->set_id(m);
+        return reinterpret_cast<Stub_Thread *>(st);
+    }*/
+
+    int id() {
+        Message * msg = new Message(_id, Message::ENTITY::TASK, Message::TASK_ID);
+        msg->act();
+        int r = msg->result();
+        return reinterpret_cast<int>(r);
+    }
+
+    void set_id(int id) {_id = id;}
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/syscall/stub_thread.h b/include/syscall/stub_thread.h
new file mode 100644
index 0000000..a266cec
--- /dev/null
+++ b/include/syscall/stub_thread.h
@@ -0,0 +1,100 @@
+// EPOS Component Declarations
+
+#ifndef __stub_thread_h
+#define __stub_thread_h
+
+#include <architecture.h>
+#include <syscall/message.h>
+#include <syscall/stub_task.h>
+
+__BEGIN_API
+
+__USING_UTIL
+
+class Stub_Thread
+{
+private:
+    int id;
+    typedef _SYS::Message Message;
+
+public:
+    Stub_Thread(){}
+
+    template<typename ... Tn>
+    Stub_Thread(int (* entry)(Tn ...), Tn ... an){
+        Message * msg = new Message(Message::ENTITY::THREAD, Message::THREAD_CREATE, entry);
+        msg->act();
+        id = msg->result();
+    }
+
+    /*
+    template<typename ... Tn>
+    Stub_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an){
+        Message * msg = new Message(THREAD, Message::THREAD_CREATE, conf, entry);
+        msg->act();
+        id = msg->result();
+    }
+    */
+
+    void set_id(int _id){id = _id;};
+
+    /*
+    void priority(const Criterion & p) {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_PRIORITY1, p);
+        msg->act();
+    }
+    */
+
+    Stub_Task * task() {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_TASK);
+        msg->act();
+        int id = msg->result();
+        Stub_Task * new_stub_task = new Stub_Task();
+        new_stub_task->set_id(id);
+        return new_stub_task;
+    }
+
+    int join() {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_JOIN);
+        msg->act();
+        return msg->result();
+    }
+
+    void pass() {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_PASS);
+        msg->act();
+    }
+
+    void suspend() {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_SUSPEND);
+        msg->act();
+    }
+
+    void resume() {
+        Message * msg = new Message(id, Message::ENTITY::THREAD, Message::THREAD_RESUME);
+        msg->act();
+    }
+
+    static Stub_Thread * self() {
+        Message * msg = new Message(Message::ENTITY::THREAD, Message::THREAD_SELF);
+        msg->act();
+        int id = msg->result();
+        Stub_Thread * new_stub_thread = new Stub_Thread();
+        new_stub_thread->set_id(id);
+        return new_stub_thread;
+    }
+
+    static void yield() {
+        Message * msg = new Message(Message::ENTITY::THREAD, Message::THREAD_YIELD);
+        msg->act();
+    }
+
+    static void exit(int status = 0) {
+        Message * msg = new Message(Message::ENTITY::THREAD, Message::THREAD_EXIT, status);
+        msg->act();
+    }
+};
+
+__END_API
+
+#endif
\ No newline at end of file
diff --git a/include/system.h b/include/system.h
index 5215ef1..cc98de1 100644
--- a/include/system.h
+++ b/include/system.h
@@ -47,6 +47,23 @@ private:
     static char _preheap[(Traits<System>::multiheap ? sizeof(Segment) : 0) + sizeof(Heap)];
     static Segment * _heap_segment;
     static Heap * _heap;
+    static Segment * _shared_segment;
+};
+
+// Class used to store and handle the shared memory heap with the "new (SHARED)" operator
+class Shared_Memory {
+    friend class Init_System;
+    friend void * ::malloc(size_t);
+    friend void ::free(void*);
+    friend void * ::operator new(size_t, const EPOS::Shared_Allocator&);
+    friend void * ::operator new[](size_t, const EPOS::Shared_Allocator&);
+    friend void ::operator delete(void*);
+    friend void ::operator delete[](void*);
+
+    private:
+    static char _preheap[sizeof(Segment) + sizeof(Heap)];
+    static Segment * _shared_heap_segment;
+    static Heap * _shared_heap;
 };
 
 __END_SYS
@@ -94,6 +111,14 @@ inline void * operator new[](size_t bytes, const EPOS::System_Allocator & alloca
     return _SYS::System::_heap->alloc(bytes);
 }
 
+inline void * operator new(size_t bytes, const EPOS::Shared_Allocator & allocator) {
+    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
+}
+
+inline void * operator new[](size_t bytes, const EPOS::Shared_Allocator & allocator) {
+    return _SYS::Shared_Memory::_shared_heap->alloc(bytes);
+}
+
 // Delete cannot be declared inline due to virtual destructors
 void operator delete(void * ptr);
 void operator delete[](void * ptr);
diff --git a/include/system/traits.h b/include/system/traits.h
index 5e505ed..7aeb447 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -93,6 +93,7 @@ class Keypad;
 // API Components
 class System;
 class Application;
+class Shared_Memory;
 
 class Thread;
 class Active;
diff --git a/include/system/types.h b/include/system/types.h
index 645c2df..d0259ba 100644
--- a/include/system/types.h
+++ b/include/system/types.h
@@ -9,6 +9,7 @@ __BEGIN_API
 
 // Memory allocators
 enum System_Allocator { SYSTEM };
+enum Shared_Allocator { SHARED };
 enum Scratchpad_Allocator { SCRATCHPAD };
 enum Color {
     COLOR_0,  COLOR_1,  COLOR_2,  COLOR_3,  COLOR_4,  COLOR_5,  COLOR_6,  COLOR_7,
@@ -44,6 +45,9 @@ inline void * operator new[](size_t s, void * a) { return a; }
 void * operator new(size_t, const EPOS::System_Allocator &);
 void * operator new[](size_t, const EPOS::System_Allocator &);
 
+void * operator new(size_t, const EPOS::Shared_Allocator &);
+void * operator new[](size_t, const EPOS::Shared_Allocator &);
+
 void * operator new(size_t, const EPOS::Scratchpad_Allocator &);
 void * operator new[](size_t, const EPOS::Scratchpad_Allocator &);
 
diff --git a/include/utility/fork.h b/include/utility/fork.h
new file mode 100644
index 0000000..c125dda
--- /dev/null
+++ b/include/utility/fork.h
@@ -0,0 +1,44 @@
+#ifndef __fork_h
+#define __fork_h
+
+#include <process.h>
+#include <architecture.h>
+
+__BEGIN_UTIL
+
+static unsigned int fork(int(* main)()) {
+    //unsigned long lr = CPU::lr();
+    Task * c_task = Task::self();
+
+    // Code
+    Segment* cs;
+    unsigned int cs_size = c_task->code_segment()->size();
+    cs = new (SYSTEM) Segment(cs_size, Segment::Flags::SYS);
+
+    CPU::int_disable();
+    CPU::Log_Addr tmp = c_task->address_space()->attach(cs);
+    memcpy(tmp, c_task->code(), cs_size);
+    c_task->address_space()->detach(cs);
+    CPU::int_enable();
+
+    // Data
+    Segment* ds;
+    unsigned int ds_size = c_task->data_segment()->size();
+    ds = new (SYSTEM) Segment(ds_size, Segment::Flags::SYS);
+
+    CPU::int_disable();
+    CPU::Log_Addr tmp_ds = c_task->address_space()->attach(ds);
+    memcpy(tmp_ds, c_task->data(), ds_size);
+    c_task->address_space()->detach(ds);
+    CPU::int_enable();
+
+    typedef int (Main)();
+    main = reinterpret_cast<Main *>(main);
+    new (SYSTEM) Task(cs, ds, main, c_task->code(), c_task->data());
+
+    return Task::self()->id();
+}
+
+__END_UTIL
+
+#endif
\ No newline at end of file
diff --git a/makedefs b/makedefs
index 8ed5c1d..69ce21e 100644
--- a/makedefs
+++ b/makedefs
@@ -147,7 +147,7 @@ ifeq ($(ARCH),armv7)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
 else
-cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes
+cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mabi=lp64 -Wno-attributes -Wno-error=stringop-overflow -mgeneral-regs-only 
 ifeq ($(SMOD), library)
 cortex_EMULATOR		= qemu-system-aarch64 -M raspi3 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
 else
@@ -156,7 +156,7 @@ endif
 endif
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_DEBUGGER		:= gdb
+cortex_DEBUGGER		:= aarch64-linux-gnu-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --nmagic
 cortex_CODE_NAME	:= .init
diff --git a/src/api/task.cc b/src/api/task.cc
new file mode 100644
index 0000000..1a188d9
--- /dev/null
+++ b/src/api/task.cc
@@ -0,0 +1,27 @@
+// EPOS Task Implementation
+
+#include <process.h>
+
+__BEGIN_SYS
+
+// Class attributes
+volatile unsigned int Task::_task_count;
+Task* volatile Task::_current;
+
+// Methods
+Task::~Task()
+{
+    db<Task>(TRC) << "~Task(this=" << this << ")" << endl;
+
+    while (!_threads.empty()){
+        delete _threads.remove()->object();
+    }
+
+    lock();
+    _task_count--;
+    unlock();
+
+    delete _as;
+}
+
+__END_SYS
\ No newline at end of file
diff --git a/src/api/thread.cc b/src/api/thread.cc
index bf94c29..d82095f 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -88,6 +88,8 @@ Thread::~Thread()
 
     if(_joining)
         _joining->resume();
+    
+    _task->remove(this);
 
     unlock();
 
@@ -344,6 +346,10 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
         }
         db<Thread>(INF) << "Thread::dispatch:next={" << next << ",ctx=" << *next->_context << "}" << endl;
 
+        if (prev->_task != next->_task) {
+            next->_task->activate_context();
+        }
+
         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
         // and necessary because of context switches, but here, we are locked() and
         // passing the volatile to switch_constext forces it to push prev onto the stack,
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index e25ab96..8923f22 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -13,8 +13,6 @@ void Thread::init()
 {
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
 
-    Criterion::init();
-
     typedef int (Main)();
 
     System_Info * si = System::info();
@@ -27,7 +25,19 @@ void Thread::init()
         // In this case, _init will have already been called, before Init_Application to construct MAIN's global objects.
         main = reinterpret_cast<Main *>(__epos_app_entry);
 
-    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
+    Criterion::init();
+
+    if (Traits<System>::multitask) {
+        Address_Space* as = new (SYSTEM) Address_Space(MMU::current());
+        Segment* cs = new (SYSTEM) Segment(Log_Addr(si->lm.app_code), si->lm.app_code_size, Segment::Flags::APPC);
+        Segment* ds = new (SYSTEM) Segment(Log_Addr(si->lm.app_data), si->lm.app_data_size, Segment::Flags::APPD);
+        Log_Addr code = si->lm.app_code;
+        Log_Addr data = si->lm.app_data;
+        new (SYSTEM) Task(as, cs, ds, main, code, data);
+    }
+    else {
+        new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(main));
+    }
 
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
@@ -48,4 +58,4 @@ void Thread::init()
     This_Thread::not_booting();
 }
 
-__END_SYS
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/armv8/armv8_cpu.cc b/src/architecture/armv8/armv8_cpu.cc
index 99fcb9e..45d8cf1 100644
--- a/src/architecture/armv8/armv8_cpu.cc
+++ b/src/architecture/armv8/armv8_cpu.cc
@@ -7,6 +7,43 @@ __BEGIN_SYS
 unsigned int CPU::_cpu_clock;
 unsigned int CPU::_bus_clock;
 
+void CPU::Context::save() volatile {
+    ASM(R"(
+        // Store Registers
+        stp x0,  x1,  [%0,  #16]
+        stp x2,  x3,  [%0, #32]
+        stp x4,  x5,  [%0, #48]
+        stp x6,  x7,  [%0, #64]
+        stp x8,  x9,  [%0, #80]
+        stp x10, x11, [%0, #96]
+        stp x12, x13, [%0, #112]
+        stp x14, x15, [%0, #128]
+        stp x16, x17, [%0, #144]
+        stp x18, x19, [%0, #160]
+        stp x20, x21, [%0, #176]
+        stp x22, x23, [%0, #192]
+        stp x24, x25, [%0, #208]
+        stp x26, x27, [%0, #224]
+        stp x28, x29, [%0, #240]
+        // Save LR and PC (Before LR)
+        adr x16, ret
+        stp x30, x16, [%0, #256]
+        
+        // Compute and store PSR
+        mrs x16, daif
+        mrs x17, nzcv
+        orr x16, x16, x17
+        mrs x17, CurrentEL
+        orr x16, x16, x17
+        mrs x17, SPSel
+        orr x16, x16, x17
+        str x16,      [%0,  #0]
+        // Restore IPC Registers
+        ldp x16, x17, [%0, #144]
+        ret: ret
+    )"::"r"(this));
+}
+
 void CPU::Context::load() const volatile
 {
     sp(this);
diff --git a/src/architecture/armv8/armv8_cpu_syscall.cc b/src/architecture/armv8/armv8_cpu_syscall.cc
new file mode 100644
index 0000000..883cc52
--- /dev/null
+++ b/src/architecture/armv8/armv8_cpu_syscall.cc
@@ -0,0 +1,21 @@
+// EPOS ARMV8 CPU System Call Entry Implementation
+
+#include <architecture/armv8/armv8_cpu.h>
+
+__BEGIN_SYS
+
+void CPU::syscall(void * msg)
+{
+    ASM(
+        //Salvando contexto
+        "str lr, [sp, #-8]!   \n"
+        "str x0, [sp, #-8]!   \n"
+        "mov %0, x0     \n" 
+        "SVC 0x0    \n"
+        "ldr lr, [sp, #8]!   \n"
+        "ldr lr, [sp, #8]!   \n"
+        "" :: "r"(msg)
+    );
+}
+
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/armv8/armv8_cpu_syscalled.cc b/src/architecture/armv8/armv8_cpu_syscalled.cc
new file mode 100644
index 0000000..bf0847f
--- /dev/null
+++ b/src/architecture/armv8/armv8_cpu_syscalled.cc
@@ -0,0 +1,16 @@
+// EPOS ARMV8 CPU System Call Entry Implementation
+
+#include <architecture/armv8/armv8_cpu.h>
+
+extern "C" { void _sysexec(); }
+
+__BEGIN_SYS
+
+void CPU::syscalled() {
+      ASM("stp x0, lr, [sp, #-16]  \n"
+          "bl _sysexec   \n"
+          "ldp x0, lr, [sp], #16  \n"
+      );
+}
+
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/armv8/armv8_crt0.S b/src/architecture/armv8/armv8_crt0.S
index 519af18..14d8214 100644
--- a/src/architecture/armv8/armv8_crt0.S
+++ b/src/architecture/armv8/armv8_crt0.S
@@ -17,7 +17,13 @@ _start:
         .globl  __epos_app_entry
         .type   __epos_app_entry, function
 __epos_app_entry:
-        // Main's stack was allocated by Thread::init()
+_user_mode:
+        stp x1, x2, [sp, #-16]! 
+        mov x1, sp
+        mrs x2, sp_el0
+        msr sp_el1, x2
+        msr sp_el0, x1
+        ldp x1, x2, [sp], #16
         bl      main
         str     x0, [sp, #-8]!	// save main's return value to be used by exit()
         bl      _fini
diff --git a/src/init/init_application.cc b/src/init/init_application.cc
index 53815ae..3ef2520 100644
--- a/src/init/init_application.cc
+++ b/src/init/init_application.cc
@@ -23,8 +23,8 @@ public:
         db<Init>(INF) << "Initializing application's heap: " << endl;
         if(Traits<System>::multiheap) { // heap in data segment arranged by SETUP
             char * heap = (MMU::align_page(&_end) >= CPU::Log_Addr(Memory_Map::APP_DATA)) ? MMU::align_page(&_end) : CPU::Log_Addr(Memory_Map::APP_DATA); // ld is eliminating the data segment in some compilations, particularly for RISC-V, and placing _end in the code segment
-            if(Traits<Build>::MODE != Traits<Build>::KERNEL) // if not a kernel, then use the stack allocated by SETUP, otherwise make that part of the heap
-                heap += MMU::align_page(Traits<Application>::STACK_SIZE);
+            // if(Traits<Build>::MODE != Traits<Build>::KERNEL) // if not a kernel, then use the stack allocated by SETUP, otherwise make that part of the heap
+            //     heap += MMU::align_page(Traits<Application>::STACK_SIZE);
             Application::_heap = new (&Application::_preheap[0]) Heap(heap, HEAP_SIZE);
         } else
             for(unsigned int frames = MMU::allocable(); frames; frames = MMU::allocable())
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index fefda22..b12fcf3 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -32,6 +32,20 @@ public:
             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
         db<Init>(INF) << "done!" << endl;
 
+        ///////////////////////////////
+
+        // If the trait sharedmemory is true, a segment with the same size of
+        // the system's heap will be allocated to be shared
+        db<Init>(INF) << "Initializing shared memory:" << endl;
+        if(Traits<System>::sharedmemory) {
+            Shared_Memory::_shared_heap_segment = new(&Shared_Memory::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SHR);
+            Shared_Memory::_shared_heap = new(&Shared_Memory::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(Shared_Memory::_shared_heap_segment), Shared_Memory::_shared_heap_segment->size());
+        }
+        db<Init>(INF)<<"done!"<<endl;
+
+        ///////////////////////////////
+
+
         db<Init>(INF) << "Initializing the machine: " << endl;
         Machine::init();
         db<Init>(INF) << "done!" << endl;
diff --git a/src/machine/cortex/cortex_ic.cc b/src/machine/cortex/cortex_ic.cc
index 3c72071..e6abf9e 100644
--- a/src/machine/cortex/cortex_ic.cc
+++ b/src/machine/cortex/cortex_ic.cc
@@ -1,5 +1,6 @@
 // EPOS ARM Cortex-A IC Mediator Implementation
 
+#include <architecture/cpu.h>
 #include <machine/machine.h>
 #include <machine/ic.h>
 #include <machine/timer.h>
@@ -97,6 +98,7 @@ void IC::data_abort()
 {
     CPU::svc_enter(CPU::MODE_ABORT, false); // enter SVC to capture LR (the faulting address) in r1
     db<IC, Machine>(TRC) << "IC::data_abort(addr=" << CPU::r1() << ")" << endl;
+    CPU::syscalled();
     CPU::svc_stay();  // undo the context saving of svc_enter(), but do not leave SVC
     kill();
 }
@@ -128,8 +130,51 @@ void IC::kill()
 extern "C" { void _dispatch(unsigned int) __attribute__ ((alias("_ZN4EPOS1S2IC8dispatchEj"))); }
 
 void IC::entry()
-{
-}
+{    
+    ASM("str        x30, [sp, # -8]!                                     \t\n\
+         stp   x28, x29, [sp, #-16]!                                     \t\n\
+         stp   x26, x27, [sp, #-16]!                                     \t\n\
+         stp   x24, x25, [sp, #-16]!                                     \t\n\
+         stp   x22, x23, [sp, #-16]!                                     \t\n\
+         stp   x20, x21, [sp, #-16]!                                     \t\n\
+         stp   x18, x19, [sp, #-16]!                                     \t\n\
+         stp   x16, x17, [sp, #-16]!                                     \t\n\
+         stp   x14, x15, [sp, #-16]!                                     \t\n\
+         stp   x12, x13, [sp, #-16]!                                     \t\n\
+         stp   x10, x11, [sp, #-16]!                                     \t\n\
+         stp    x8,  x9, [sp, #-16]!                                     \t\n\
+         stp    x6,  x7, [sp, #-16]!                                     \t\n\
+         stp    x4,  x5, [sp, #-16]!                                     \t\n\
+         stp    x2,  x3, [sp, #-16]!                                     \t\n\
+         stp    x0,  x1, [sp, #-16]!                                     \t\n\
+         mrs x30, elr_el1                                               \t\n\
+         str        x30, [sp, # -8]!                                     \t\n\
+         mrs x30, spsr_el1                                              \t\n\
+         str        x30, [sp, # -8]!                                     \t" : : : "cc");
+
+    dispatch(int_id());
+
+    ASM("ldr         x30, [sp], #8                                       \t\n\
+         msr  spsr_el1, x30                                              \t\n\
+         ldr         x30, [sp], #8                                       \t\n\
+         msr  elr_el1, x30                                               \t\n\
+         ldp    x0,  x1, [sp], #16                                       \t\n\
+         ldp    x2,  x3, [sp], #16                                       \t\n\
+         ldp    x4,  x5, [sp], #16                                       \t\n\
+         ldp    x6,  x7, [sp], #16                                       \t\n\
+         ldp    x8,  x9, [sp], #16                                       \t\n\
+         ldp   x10, x11, [sp], #16                                       \t\n\
+         ldp   x12, x13, [sp], #16                                       \t\n\
+         ldp   x14, x15, [sp], #16                                       \t\n\
+         ldp   x16, x17, [sp], #16                                       \t\n\
+         ldp   x18, x19, [sp], #16                                       \t\n\
+         ldp   x20, x21, [sp], #16                                       \t\n\
+         ldp   x22, x23, [sp], #16                                       \t\n\
+         ldp   x24, x25, [sp], #16                                       \t\n\
+         ldp   x26, x27, [sp], #16                                       \t\n\
+         ldp   x28, x29, [sp], #16                                       \t\n\
+         ldr        x30, [sp], #8                                        \t" : : : "cc");
+ }
 
 #endif    
 
diff --git a/src/setup/setup_raspberry_pi3.cc b/src/setup/setup_raspberry_pi3.cc
index e929cba..f603fb1 100644
--- a/src/setup/setup_raspberry_pi3.cc
+++ b/src/setup/setup_raspberry_pi3.cc
@@ -737,7 +737,8 @@ void Setup::enable_paging()
 #ifdef __arch_armv7__
 
     // MNG_DOMAIN for no page permission verification, CLI_DOMAIN otherwise
-    CPU::dacr((Traits<System>::multitask) ? CPU::CLI_DOMAIN : CPU::MNG_DOMAIN); 
+    // CPU::dacr((Traits<System>::multitask) ? CPU::CLI_DOMAIN : CPU::MNG_DOMAIN); 
+    CPU::dacr(CPU::MNG_DOMAIN);
 
     CPU::dsb();
     CPU::isb();
@@ -1050,135 +1051,211 @@ void _vector_table()
     // Therefore, each exception level maps the four exception type handlers aligned by 128 bytes (enough room to write simple handlers).
 
     // Our strategy is to forward all interrupts to _int_entry via
-    ASM("// Current EL with SP0                                                 \t\n\
+    ASM("                                                                       \t\n\
                         .balign 128                                             \t\n\
         .sync_curr_sp0: str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #0                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .irq_curr_sp0:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #1                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
-                        .balign 128                                             \t\n\
+                       .balign 128                                             \t\n\
         .fiq_curr_sp0:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #2                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .error_curr_sp0:str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #3                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
-        // Current EL with SPx                                                  \t\n\
                         .balign 128                                             \t\n\
         .sync_curr_spx: str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #4                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .irq_curr_spx:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #5                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .fiq_curr_spx:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #6                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .error_curr_spx:str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #7                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
         // Lower EL using AArch64                                               \t\n\
-                        .balign 128                                             \t\n\
+                         .balign 128                                             \t\n\
         .sync_lower64:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x28, [sp,#-8]!                                      \t\n\
+                        mrs x28, CurrentEL                                      \t\n\
+                        and x28, x28, #12                                       \t\n\
+                        lsr x28, x28, #2                                        \t\n\
+                                                                                \t\n\
+                        cmp x28, #2                                             \t\n\
+                        beq .1                                                  \t\n\
                         ldr x29, .ic_entry                                      \t\n\
-                        blr x29                                                 \t\n\
+                        b .2                                                    \t\n\
+                    .1:                                                         \t\n\
+                        dsb   ishst                                             \t\n\
+                        tlbi  alle1                                             \t\n\
+                        dsb   ish                                               \t\n\
+                        isb                                                     \t\n\
+                    .2:                                                         \t\n\
+                        ldr x28, [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .irq_lower64:   str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #9                                              \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .fiq_lower64:   str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #10                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .error_lower64: str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #11                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
+                                                                                 \t\n\
                                                                                 \t\n\
                         // Lower EL using AArch32                               \t\n\
                         .balign 128                                             \t\n\
         .sync_lower32:  str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #12                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .irq_lower32:   str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #13                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
         .fiq_lower32:   str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #14                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
                         .balign 128                                             \t\n\
+                                                                                \t\n\
         .error_lower32: str x30, [sp,#-8]!                                      \t\n\
                         str x29, [sp,#-8]!                                      \t\n\
+                        str x0,  [sp,#-8]!                                      \t\n\
                         ldr x29, .ic_entry                                      \t\n\
+                        mov x0, #15                                             \t\n\
                         blr x29                                                 \t\n\
+                        ldr x0,  [sp], #8                                       \t\n\
+                        ldr x29, [sp], #8                                       \t\n\
                         ldr x30, [sp], #8                                       \t\n\
                         eret                                                    \t\n\
                                                                                 \t\n\
diff --git a/src/system/application_binding.cc b/src/system/application_binding.cc
new file mode 100644
index 0000000..c379b2c
--- /dev/null
+++ b/src/system/application_binding.cc
@@ -0,0 +1,38 @@
+// EPOS Applicaiton Component Implementation
+
+#include <utility/ostream.h>
+#include <utility/heap.h>
+#include <machine.h>
+#include <memory.h>
+#include <process.h>
+#include <system.h>
+#include <syscall/stub_thread.h>
+
+__BEGIN_SYS
+OStream kout;
+OStream kerr;
+__END_SYS
+
+
+// Bindings
+extern "C" {
+    // Libc legacy
+    void _panic() { _API::Stub_Thread::exit(-1); }
+    void _exit(int s) { _API::Stub_Thread::exit(s); for(;;); }
+
+    void __exit() { _API::Stub_Thread::exit(_SYS::CPU::fr()); }  // must be handled by the Page Fault handler for user-level tasks
+    //void __cxa_pure_virtual() { db<void>(ERR) << "Pure Virtual method called!" << endl; }
+}
+
+__USING_SYS;
+// Bindings
+extern "C" {
+    void _syscall(void * m) { CPU::syscall(m); }
+
+    // OStream
+    void _print(const char * s) {
+        // Message msg(Message::ENTITY::DISPLAY, Message::PRINT, reinterpret_cast<int>(s));
+        Message msg(Message::ENTITY::DISPLAY, Message::PRINT, s);
+        msg.act();
+    }
+}
\ No newline at end of file
diff --git a/src/system/makefile b/src/system/makefile
index 6967702..84161cb 100644
--- a/src/system/makefile
+++ b/src/system/makefile
@@ -31,7 +31,7 @@ system_builtin_$(MMOD): $(OBJS)
 		--section-start $(MACH_DATA_NAME)=$(SYS_DATA_ADDR) \
 		--entry=_init -o system_$(MMOD) \
 		$(LIB)/crtbegin_$(MMOD).o \
-		system_scaffold.o \
+		system_scaffold.o system_bindings.o\
 		$(LIB)/crtend_$(MMOD).o \
 		--whole-archive \
 		-l$(LSYS) -l$(LMACH) -l$(LARCH) \
@@ -45,13 +45,13 @@ system_kernel_$(MMOD): $(OBJS)
 		--section-start $(MACH_DATA_NAME)=$(SYS_DATA_ADDR) \
 		--entry=_init -o system_$(MMOD) \
 		$(LIB)/crtbegin_$(MMOD).o \
-		system_scaffold.o \
+		system_scaffold.o system_bindings.o\
 		$(LIB)/crtend_$(MMOD).o \
 		--whole-archive \
 		-l$(LSYS) -l$(LMACH) -l$(LARCH) \
 		--no-whole-archive \
 		-l$(LUTIL) -lgcc
-		$(LD) $(LDFLAGS) -i application_scaffold.o -o application_$(MMOD).o
+		$(LD) $(LDFLAGS) -i application_scaffold.o application_binding.o -o application_$(MMOD).o
 
 clean:
 		$(CLEAN) *.o $(shell find -maxdepth 1 -executable -not -type d)
diff --git a/src/system/system_bindings.cc b/src/system/system_bindings.cc
new file mode 100644
index 0000000..dfaa7c9
--- /dev/null
+++ b/src/system/system_bindings.cc
@@ -0,0 +1,25 @@
+// EPOS System Scaffold and System Component Implementation
+
+#include <utility/ostream.h>
+#include <utility/heap.h>
+#include <machine.h>
+#include <memory.h>
+#include <process.h>
+#include <system.h>
+#include <syscall/agent.h>
+
+// Bindings
+extern "C" {
+    __USING_SYS;
+    // Libc legacy
+    void _panic() { Machine::panic(); }
+    void _exit(int s) { Thread::exit(s); for(;;); }
+    void __exit() { Thread::exit(CPU::fr()); }  // must be handled by the Page Fault handler for user-level tasks
+    void __cxa_pure_virtual() { db<void>(ERR) << "Pure Virtual method called!" << endl; }
+    void _syscall(void *m) { CPU::syscall(m); } 
+    void _sysexec() { Agent::_exec(); } 
+
+    // Utility-related methods that differ from kernel and user space.
+    // OStream
+    void _print(const char * s) { Display::puts(s); }
+}
\ No newline at end of file
diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
index 941d0d0..ea69eec 100644
--- a/src/system/system_scaffold.cc
+++ b/src/system/system_scaffold.cc
@@ -21,20 +21,23 @@ System_Info * System::_si = (Memory_Map::SYS_INFO != Memory_Map::NOT_USED) ? rei
 char System::_preheap[];
 Segment * System::_heap_segment;
 Heap * System::_heap;
+char Shared_Memory::_preheap[];
+Segment * Shared_Memory:: _shared_heap_segment;
+Heap * Shared_Memory:: _shared_heap;
 
 __END_SYS
 
-// Bindings
-extern "C" {
-    __USING_SYS;
+// // Bindings
+// extern "C" {
+//     __USING_SYS;
 
-    // Libc legacy
-    void _panic() { Machine::panic(); }
-    void _exit(int s) { Thread::exit(s); for(;;); }
-    void __exit() { Thread::exit(CPU::fr()); }  // must be handled by the Page Fault handler for user-level tasks
-    void __cxa_pure_virtual() { db<void>(ERR) << "Pure Virtual method called!" << endl; }
+//     // Libc legacy
+//     void _panic() { Machine::panic(); }
+//     void _exit(int s) { Thread::exit(s); for(;;); }
+//     void __exit() { Thread::exit(CPU::fr()); }  // must be handled by the Page Fault handler for user-level tasks
+//     void __cxa_pure_virtual() { db<void>(ERR) << "Pure Virtual method called!" << endl; }
 
-    // Utility-related methods that differ from kernel and user space.
-    // OStream
-    void _print(const char * s) { Display::puts(s); }
-}
+//     // Utility-related methods that differ from kernel and user space.
+//     // OStream
+//     void _print(const char * s) { Display::puts(s); }
+// }
diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
index 0c8a293..389ee3a 100644
--- a/tools/eposcc/eposcc
+++ b/tools/eposcc/eposcc
@@ -33,9 +33,9 @@ CONFIGURATOR=eposcfg
 
 COMP_FLGS="-include $INC/system.h"
 COMP_HDRS="$INC"
-if [ "$SMOD" = "kernel" ] ; then
-COMP_FLGS="$COMP_FLGS -include $INC/framework/main.h"
-fi
+# if [ "$SMOD" = "kernel" ] ; then
+# COMP_FLGS="$COMP_FLGS -include $INC/framework/main.h"
+# fi
 
 C_COMPILER="$TOOLS_PREFIX""gcc"
 C_COMP_FLGS="$MACH_CC_FLAGS"
